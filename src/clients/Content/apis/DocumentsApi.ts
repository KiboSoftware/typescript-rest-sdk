/* tslint:disable */
/* eslint-disable */
/**
 * Kibo Content Service
 * OpenAPI Spec for Kibo Content Service
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../client-runtime';
import { basePathTemplate } from '../api-path';
import type {
  Document,
  DocumentCollection,
  DocumentCopyRequest,
  DocumentCopyResponse,
  DocumentMoveSummary,
  HttpRequestMessage,
} from '../models';
import {
    DocumentFromJSON,
    DocumentToJSON,
    DocumentCollectionFromJSON,
    DocumentCollectionToJSON,
    DocumentCopyRequestFromJSON,
    DocumentCopyRequestToJSON,
    DocumentCopyResponseFromJSON,
    DocumentCopyResponseToJSON,
    DocumentMoveSummaryFromJSON,
    DocumentMoveSummaryToJSON,
    HttpRequestMessageFromJSON,
    HttpRequestMessageToJSON,
} from '../models';

export interface DocumentsApiCopyDocumentsRequest {
    documentListName: string;
    documentCopyRequest?: DocumentCopyRequest;
}

export interface DocumentsApiCreateDocumentRequest {
    documentListName: string;
    document?: Document;
}

export interface DocumentsApiDeleteByPathRequest {
    documentListName: string;
    path?: string;
}

export interface DocumentsApiDeleteDocumentRequest {
    documentListName: string;
    documentId: string;
}

export interface DocumentsApiDeleteDocumentContentRequest {
    documentListName: string;
    documentId: string;
}

export interface DocumentsApiDeleteTreeDocumentContentRequest {
    documentListName: string;
    documentName: string;
    httpRequestMessage?: HttpRequestMessage;
}

export interface DocumentsApiGetDocumentRequest {
    documentListName: string;
    documentId: string;
    includeInactive?: boolean;
}

export interface DocumentsApiGetDocumentContentRequest {
    documentListName: string;
    documentId: string;
}

export interface DocumentsApiGetDocumentContentHeadRequest {
    documentListName: string;
    documentId: string;
    includeInactive?: string;
}

export interface DocumentsApiGetDocumentsRequest {
    documentListName: string;
    filter?: string;
    sortBy?: string;
    pageSize?: number;
    startIndex?: number;
    includeInactive?: boolean;
    path?: string;
    includeSubPaths?: boolean;
    queryScope?: string;
}

export interface DocumentsApiGetTreeDocumentRequest {
    documentListName: string;
    documentName: string;
    includeInactive?: boolean;
}

export interface DocumentsApiGetTreeDocumentContentRequest {
    documentListName: string;
    documentName: string;
}

export interface DocumentsApiGetTreeDocumentContentHeadRequest {
    documentListName: string;
    documentName: string;
}

export interface DocumentsApiMoveByPathRequest {
    documentListName: string;
    sourcePath?: string;
    destPath?: string;
    renameDuplicates?: boolean;
    previewMode?: boolean;
}

export interface DocumentsApiPatchDocumentRequest {
    documentListName: string;
    documentId: string;
    document?: Document;
}

export interface DocumentsApiTransformDocumentContentRequest {
    documentListName: string;
    documentId: string;
    width?: number;
    height?: number;
    max?: number;
    maxWidth?: number;
    maxHeight?: number;
    crop?: string;
    quality?: number;
}

export interface DocumentsApiTransformTreeDocumentContentRequest {
    documentListName: string;
    documentName: string;
    width?: number;
    height?: number;
    max?: number;
    maxWidth?: number;
    maxHeight?: number;
    crop?: string;
    quality?: number;
}

export interface DocumentsApiUpdateDocumentRequest {
    documentListName: string;
    documentId: string;
    document?: Document;
}

export interface DocumentsApiUpdateDocumentContentRequest {
    documentListName: string;
    documentId: string;
    httpRequestMessage?: HttpRequestMessage;
}

export interface DocumentsApiUpdateTreeDocumentContentRequest {
    documentListName: string;
    documentName: string;
    httpRequestMessage?: HttpRequestMessage;
}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI {
    constructor(configuration?) {
        super(configuration)
        this.basePathTemplate = basePathTemplate
    }
    /**
     * Copy Document
     * Copy Document
     */


    async copyDocumentsRaw(requestParameters: DocumentsApiCopyDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentCopyResponse>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling copyDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/copy`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentCopyRequestToJSON(requestParameters.documentCopyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentCopyResponseFromJSON(jsonValue));
    }

    /**
     * Copy Document
     * Copy Document
     */
    async copyDocuments(requestParameters: DocumentsApiCopyDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentCopyResponse> {
        const response = await this.copyDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Document
     * Create Document
     */


    async createDocumentRaw(requestParameters: DocumentsApiCreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling createDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Create Document
     * Create Document
     */
    async createDocument(requestParameters: DocumentsApiCreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.createDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Document
     * Delete Document
     */


    async deleteByPathRaw(requestParameters: DocumentsApiDeleteByPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling deleteByPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Document
     * Delete Document
     */
    async deleteByPath(requestParameters: DocumentsApiDeleteByPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteByPathRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Document
     * Delete Document
     */


    async deleteDocumentRaw(requestParameters: DocumentsApiDeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling deleteDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Document
     * Delete Document
     */
    async deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDocumentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Document Content
     * Delete Document Content
     */


    async deleteDocumentContentRaw(requestParameters: DocumentsApiDeleteDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling deleteDocumentContent.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling deleteDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Document Content
     * Delete Document Content
     */
    async deleteDocumentContent(requestParameters: DocumentsApiDeleteDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Document Content by Path
     * Delete Document Content by Path
     */


    async deleteTreeDocumentContentRaw(requestParameters: DocumentsApiDeleteTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling deleteTreeDocumentContent.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling deleteTreeDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: HttpRequestMessageToJSON(requestParameters.httpRequestMessage),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Document Content by Path
     * Delete Document Content by Path
     */
    async deleteTreeDocumentContent(requestParameters: DocumentsApiDeleteTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTreeDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Get Document
     * Get Document
     */


    async getDocumentRaw(requestParameters: DocumentsApiGetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Get Document
     * Get Document
     */
    async getDocument(requestParameters: DocumentsApiGetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Document Content
     * Get Document Content
     */


    async getDocumentContentRaw(requestParameters: DocumentsApiGetDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getDocumentContent.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get Document Content
     * Get Document Content
     */
    async getDocumentContent(requestParameters: DocumentsApiGetDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Get Document Content Headers
     * Get Document Content Headers
     */


    async getDocumentContentHeadRaw(requestParameters: DocumentsApiGetDocumentContentHeadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getDocumentContentHead.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocumentContentHead.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get Document Content Headers
     * Get Document Content Headers
     */
    async getDocumentContentHead(requestParameters: DocumentsApiGetDocumentContentHeadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getDocumentContentHeadRaw(requestParameters, initOverrides);
    }

    /**
     * Get Documents
     * Get Documents
     */


    async getDocumentsRaw(requestParameters: DocumentsApiGetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentCollection>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getDocuments.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['startIndex'] = requestParameters.startIndex;
        }

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.includeSubPaths !== undefined) {
            queryParameters['includeSubPaths'] = requestParameters.includeSubPaths;
        }

        if (requestParameters.queryScope !== undefined) {
            queryParameters['queryScope'] = requestParameters.queryScope;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentCollectionFromJSON(jsonValue));
    }

    /**
     * Get Documents
     * Get Documents
     */
    async getDocuments(requestParameters: DocumentsApiGetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentCollection> {
        const response = await this.getDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a specific Document within the specified ContentCollection using the specified document name, unique within a specific folder with the specified documentId, version, and status.
     * Get Document by Path
     */


    async getTreeDocumentRaw(requestParameters: DocumentsApiGetTreeDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getTreeDocument.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling getTreeDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Retrieves a specific Document within the specified ContentCollection using the specified document name, unique within a specific folder with the specified documentId, version, and status.
     * Get Document by Path
     */
    async getTreeDocument(requestParameters: DocumentsApiGetTreeDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.getTreeDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns transformations on a document. For example, resizing an image.
     * Get Document Content by Path
     */


    async getTreeDocumentContentRaw(requestParameters: DocumentsApiGetTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getTreeDocumentContent.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling getTreeDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns transformations on a document. For example, resizing an image.
     * Get Document Content by Path
     */
    async getTreeDocumentContent(requestParameters: DocumentsApiGetTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getTreeDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Get Document Content Headers by Path
     * Get Document Content Headers by Path
     */


    async getTreeDocumentContentHeadRaw(requestParameters: DocumentsApiGetTreeDocumentContentHeadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling getTreeDocumentContentHead.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling getTreeDocumentContentHead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get Document Content Headers by Path
     * Get Document Content Headers by Path
     */
    async getTreeDocumentContentHead(requestParameters: DocumentsApiGetTreeDocumentContentHeadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getTreeDocumentContentHeadRaw(requestParameters, initOverrides);
    }

    /**
     * Move Document
     * Move Document
     */


    async moveByPathRaw(requestParameters: DocumentsApiMoveByPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentMoveSummary>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling moveByPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourcePath !== undefined) {
            queryParameters['sourcePath'] = requestParameters.sourcePath;
        }

        if (requestParameters.destPath !== undefined) {
            queryParameters['destPath'] = requestParameters.destPath;
        }

        if (requestParameters.renameDuplicates !== undefined) {
            queryParameters['renameDuplicates'] = requestParameters.renameDuplicates;
        }

        if (requestParameters.previewMode !== undefined) {
            queryParameters['previewMode'] = requestParameters.previewMode;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/move`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentMoveSummaryFromJSON(jsonValue));
    }

    /**
     * Move Document
     * Move Document
     */
    async moveByPath(requestParameters: DocumentsApiMoveByPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentMoveSummary> {
        const response = await this.moveByPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Patch Document
     * Patch Document
     */


    async patchDocumentRaw(requestParameters: DocumentsApiPatchDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling patchDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling patchDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Patch Document
     * Patch Document
     */
    async patchDocument(requestParameters: DocumentsApiPatchDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.patchDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns transformations on a document. For example, resizing an image.
     * Get Resized Image
     */


    async transformDocumentContentRaw(requestParameters: DocumentsApiTransformDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling transformDocumentContent.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling transformDocumentContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.width !== undefined) {
            queryParameters['width'] = requestParameters.width;
        }

        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.max !== undefined) {
            queryParameters['max'] = requestParameters.max;
        }

        if (requestParameters.maxWidth !== undefined) {
            queryParameters['maxWidth'] = requestParameters.maxWidth;
        }

        if (requestParameters.maxHeight !== undefined) {
            queryParameters['maxHeight'] = requestParameters.maxHeight;
        }

        if (requestParameters.crop !== undefined) {
            queryParameters['crop'] = requestParameters.crop;
        }

        if (requestParameters.quality !== undefined) {
            queryParameters['quality'] = requestParameters.quality;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}/transform`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns transformations on a document. For example, resizing an image.
     * Get Resized Image
     */
    async transformDocumentContent(requestParameters: DocumentsApiTransformDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.transformDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Returns transformations on a document. For example, resizing an image. By Path
     * Get Resized Image by Path
     */


    async transformTreeDocumentContentRaw(requestParameters: DocumentsApiTransformTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling transformTreeDocumentContent.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling transformTreeDocumentContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.width !== undefined) {
            queryParameters['width'] = requestParameters.width;
        }

        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.max !== undefined) {
            queryParameters['max'] = requestParameters.max;
        }

        if (requestParameters.maxWidth !== undefined) {
            queryParameters['maxWidth'] = requestParameters.maxWidth;
        }

        if (requestParameters.maxHeight !== undefined) {
            queryParameters['maxHeight'] = requestParameters.maxHeight;
        }

        if (requestParameters.crop !== undefined) {
            queryParameters['crop'] = requestParameters.crop;
        }

        if (requestParameters.quality !== undefined) {
            queryParameters['quality'] = requestParameters.quality;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}/transform`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns transformations on a document. For example, resizing an image. By Path
     * Get Resized Image by Path
     */
    async transformTreeDocumentContent(requestParameters: DocumentsApiTransformTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.transformTreeDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Update Document
     * Update Document
     */


    async updateDocumentRaw(requestParameters: DocumentsApiUpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling updateDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling updateDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Update Document
     * Update Document
     */
    async updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.updateDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Document Content
     * Update Document Content
     */


    async updateDocumentContentRaw(requestParameters: DocumentsApiUpdateDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling updateDocumentContent.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling updateDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documents/{documentId}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: HttpRequestMessageToJSON(requestParameters.httpRequestMessage),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Document Content
     * Update Document Content
     */
    async updateDocumentContent(requestParameters: DocumentsApiUpdateDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateDocumentContentRaw(requestParameters, initOverrides);
    }

    /**
     * Update Document Content by Path
     * Update Document Content by Path
     */


    async updateTreeDocumentContentRaw(requestParameters: DocumentsApiUpdateTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.documentListName === null || requestParameters.documentListName === undefined) {
            throw new runtime.RequiredError('documentListName','Required parameter requestParameters.documentListName was null or undefined when calling updateTreeDocumentContent.');
        }

        if (requestParameters.documentName === null || requestParameters.documentName === undefined) {
            throw new runtime.RequiredError('documentName','Required parameter requestParameters.documentName was null or undefined when calling updateTreeDocumentContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';





        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/content/documentlists/{documentListName}/documentTree/{documentName}/content`.replace(`{${"documentListName"}}`, encodeURIComponent(String(requestParameters.documentListName))).replace(`{${"documentName"}}`, encodeURIComponent(String(requestParameters.documentName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: HttpRequestMessageToJSON(requestParameters.httpRequestMessage),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Document Content by Path
     * Update Document Content by Path
     */
    async updateTreeDocumentContent(requestParameters: DocumentsApiUpdateTreeDocumentContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTreeDocumentContentRaw(requestParameters, initOverrides);
    }

}

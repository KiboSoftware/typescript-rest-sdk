/* tslint:disable */
/* eslint-disable */
/**
 * Kibo Fulfillment Service
 * OpenAPI Spec for Kibo Fulfillment Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../client-runtime';
import { basePathTemplate } from '../api-path';
import type {
  BackorderItemsRequestDto,
  BackorderItemsUpdateRequestDto,
  BackorderShipmentRequestDto,
  CancelItemsRequestDto,
  CancelShipmentRequestDto,
  CollectionModelEntityModelShipmentDto,
  CollectionModelLocationSummaryDto,
  CollectionModelShipmentDto,
  DestinationDto,
  EntityModelDashboardResponseDto,
  EntityModelRenderedContentDto,
  EntityModelShipmentDto,
  ErrorItem,
  GetShipmentsRequest,
  GiftCardInfoRequestDto,
  ItemDto,
  PagedModelEntityModelShipmentDto,
  PickupItemsRequestDto,
  ReadyForPrepItemsRequestDto,
  ReassignItemsRequestDto,
  ReassignShipmentRequestDto,
  RejectItemsRequestDto,
  RejectShipmentRequestDto,
  RemoveSpecificShipmentFromConsolidationGroup400Response,
  ShipmentDto,
  TaskCompleteDto,
  TaskDto,
  TransferItemsRequestDto,
  TransferShipmentRequestDto,
} from '../models';


export namespace shipmentApiParams { 
    export interface BackorderItemsRequest {
        shipmentNumber: number;
        backorderItemsRequestDto: BackorderItemsRequestDto;
        ifMatch?: string;
    }
    export interface BackorderItemsUpdateRequest {
        shipmentNumber: number;
        backorderItemsUpdateRequestDto: BackorderItemsUpdateRequestDto;
        ifMatch?: string;
    }
    export interface BackorderShipmentRequest {
        shipmentNumber: number;
        backorderShipmentRequestDto: BackorderShipmentRequestDto;
        ifMatch?: string;
    }
    export interface CancelItemsRequest {
        shipmentNumber: number;
        cancelItemsRequestDto: CancelItemsRequestDto;
        ifMatch?: string;
    }
    export interface CancelShipmentRequest {
        shipmentNumber: number;
        cancelShipmentRequestDto: CancelShipmentRequestDto;
        ifMatch?: string;
    }
    export interface CancelShipmentsRequest {
        orderId: string;
        cancelShipmentRequestDto: CancelShipmentRequestDto;
    }
    export interface CustomerAtCurbsideRequest {
        shipmentNumber: number;
        requestBody: { [key: string]: object; };
        ifMatch?: string;
    }
    export interface CustomerAtStoreRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface CustomerCareItemsRequest {
        shipmentNumber: number;
        rejectItemsRequestDto: RejectItemsRequestDto;
        ifMatch?: string;
    }
    export interface CustomerCareShipmentRequest {
        shipmentNumber: number;
        rejectShipmentRequestDto: RejectShipmentRequestDto;
        ifMatch?: string;
    }
    export interface CustomerInTransitRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface DeleteShipmentRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface DeleteShipmentsOfOrderRequest {
        orderId: string;
    }
    export interface DestinationUpdateRequest {
        shipmentNumber: number;
        destinationDto: DestinationDto;
        ifMatch?: string;
    }
    export interface ExecuteRequest {
        shipmentNumber: number;
        taskName: string;
        taskCompleteDto: TaskCompleteDto;
        ifMatch?: string;
    }
    export interface FulfillShipmentRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface GetLocationSummaryReportRequest {
        locationCodes: Array<string>;
        startDateTime: string;
        bypassSearchIndex?: boolean;
    }
    export interface GetShipmentRequest {
        shipmentNumber: number;
    }
    export interface GetShipmentStepCountByShipmentTypeRequest {
        shipmentType: string;
        assignedLocations?: Array<string>;
    }
    export interface GetShipmentsOperationRequest {
        request: GetShipmentsRequest;
    }
    export interface GetTasksRequest {
        shipmentNumber: number;
    }
    export interface ItemsReadyForPrepRequest {
        shipmentNumber: number;
        readyForPrepItemsRequestDto: ReadyForPrepItemsRequestDto;
        ifMatch?: string;
    }
    export interface NewShipmentRequest {
        shipmentDto: ShipmentDto;
    }
    export interface NewShipmentsRequest {
        shipmentDto: Array<ShipmentDto>;
    }
    export interface PickupItemsRequest {
        shipmentNumber: number;
        pickupItemsRequestDto: PickupItemsRequestDto;
        ifMatch?: string;
    }
    export interface ReassignItemsRequest {
        shipmentNumber: number;
        reassignItemsRequestDto: ReassignItemsRequestDto;
        ifMatch?: string;
    }
    export interface ReassignShipmentRequest {
        shipmentNumber: number;
        reassignShipmentRequestDto: ReassignShipmentRequestDto;
        ifMatch?: string;
    }
    export interface ReceiveTransferRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface RefreshShipmentRequest {
        shipmentNumber: number;
        shouldLog?: boolean;
        ifMatch?: string;
    }
    export interface RejectItemsRequest {
        shipmentNumber: number;
        rejectItemsRequestDto: RejectItemsRequestDto;
        ifMatch?: string;
    }
    export interface RejectShipmentRequest {
        shipmentNumber: number;
        rejectShipmentRequestDto: RejectShipmentRequestDto;
        ifMatch?: string;
    }
    export interface RenderOrderSummaryRequest {
        shipmentNumber: number;
    }
    export interface RenderPackingSlipRequest {
        shipmentNumber: number;
    }
    export interface ReplaceShipmentRequest {
        shipmentNumber: number;
        shipmentDto: ShipmentDto;
        updateFields?: Array<string>;
        ifMatch?: string;
    }
    export interface ResendItemEmailRequest {
        shipmentNumber: number;
        lineId: number;
        ifMatch?: string;
    }
    export interface ResendShipmentEmailRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface RetryFulfillingShipmentRequest {
        shipmentNumber: number;
        ifMatch?: string;
    }
    export interface RevertRequest {
        shipmentNumber: number;
        taskName: string;
        ifMatch?: string;
    }
    export interface SearchAndReceiveTransferRequest {
        search: string;
        ifMatch?: string;
    }
    export interface SearchReceivableShipmentRequest {
        search: string;
    }
    export interface SkipTaskRequest {
        shipmentNumber: number;
        taskName: string;
        ifMatch?: string;
    }
    export interface TransferItemsRequest {
        shipmentNumber: number;
        transferItemsRequestDto: TransferItemsRequestDto;
        ifMatch?: string;
    }
    export interface TransferShipmentRequest {
        shipmentNumber: number;
        transferShipmentRequestDto: TransferShipmentRequestDto;
        ifMatch?: string;
    }
    export interface UpdateFulfillmentFieldsRequest {
        shipmentNumber: number;
        itemDto: Array<ItemDto>;
        ifMatch?: string;
    }
    export interface UpdateGiftCardInfoRequest {
        shipmentNumber: number;
        giftCardInfoRequestDto: GiftCardInfoRequestDto;
        ifMatch?: string;
    }
    export interface WorkflowDefinitionImageRequest {
        shipmentNumber: number;
    }
    export interface WorkflowInstanceImageRequest {
        shipmentNumber: number;
    }
}
/**
* ShipmentApiService - interface
* 
* @export
* @interface ShipmentApi
*/
export interface ShipmentApiService {
    /**
    * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
    * @summary Backorder Items
    * @param {number} shipmentNumber 
    * @param {BackorderItemsRequestDto} backorderItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    backorderItemsRaw(requestParameters: shipmentApiParams.BackorderItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
    * Backorder Items
    */
    backorderItems(requestParameters: shipmentApiParams.BackorderItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
    * @summary Backorder Items Update
    * @param {number} shipmentNumber 
    * @param {BackorderItemsUpdateRequestDto} backorderItemsUpdateRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    backorderItemsUpdateRaw(requestParameters: shipmentApiParams.BackorderItemsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
    * Backorder Items Update
    */
    backorderItemsUpdate(requestParameters: shipmentApiParams.BackorderItemsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
    * @summary Backorder Shipment
    * @param {number} shipmentNumber 
    * @param {BackorderShipmentRequestDto} backorderShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    backorderShipmentRaw(requestParameters: shipmentApiParams.BackorderShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
    * Backorder Shipment
    */
    backorderShipment(requestParameters: shipmentApiParams.BackorderShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Cancel Items
    * @summary Cancel Items
    * @param {number} shipmentNumber 
    * @param {CancelItemsRequestDto} cancelItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    cancelItemsRaw(requestParameters: shipmentApiParams.CancelItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Cancel Items
    * Cancel Items
    */
    cancelItems(requestParameters: shipmentApiParams.CancelItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Cancel Shipment
    * @summary Cancel Shipment
    * @param {number} shipmentNumber 
    * @param {CancelShipmentRequestDto} cancelShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    cancelShipmentRaw(requestParameters: shipmentApiParams.CancelShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Cancel Shipment
    * Cancel Shipment
    */
    cancelShipment(requestParameters: shipmentApiParams.CancelShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Cancel Shipments
    * @summary Cancel Shipments
    * @param {string} orderId 
    * @param {CancelShipmentRequestDto} cancelShipmentRequestDto 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    cancelShipmentsRaw(requestParameters: shipmentApiParams.CancelShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelShipmentDto>>;

    /**
    * Cancel Shipments
    * Cancel Shipments
    */
    cancelShipments(requestParameters: shipmentApiParams.CancelShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelShipmentDto>;

    /**
    * Indicate that a customer has arrived for curbside pickup of this shipment.
    * @summary Customer At Curbside
    * @param {number} shipmentNumber 
    * @param {{ [key: string]: object; }} requestBody 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    customerAtCurbsideRaw(requestParameters: shipmentApiParams.CustomerAtCurbsideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Indicate that a customer has arrived for curbside pickup of this shipment.
    * Customer At Curbside
    */
    customerAtCurbside(requestParameters: shipmentApiParams.CustomerAtCurbsideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Indicate that the customer has arrived for store pickup of this shipment.
    * @summary Customer At Store
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    customerAtStoreRaw(requestParameters: shipmentApiParams.CustomerAtStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Indicate that the customer has arrived for store pickup of this shipment.
    * Customer At Store
    */
    customerAtStore(requestParameters: shipmentApiParams.CustomerAtStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Send items to Customer Care
    * @summary Customer Care Items
    * @param {number} shipmentNumber 
    * @param {RejectItemsRequestDto} rejectItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    customerCareItemsRaw(requestParameters: shipmentApiParams.CustomerCareItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Send items to Customer Care
    * Customer Care Items
    */
    customerCareItems(requestParameters: shipmentApiParams.CustomerCareItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Send a shipment to Customer Care
    * @summary Customer Care Shipment
    * @param {number} shipmentNumber 
    * @param {RejectShipmentRequestDto} rejectShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    customerCareShipmentRaw(requestParameters: shipmentApiParams.CustomerCareShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Send a shipment to Customer Care
    * Customer Care Shipment
    */
    customerCareShipment(requestParameters: shipmentApiParams.CustomerCareShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Indicate that a customer is on their way to the store for curbside delivery.
    * @summary Customer In Transit
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    customerInTransitRaw(requestParameters: shipmentApiParams.CustomerInTransitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Indicate that a customer is on their way to the store for curbside delivery.
    * Customer In Transit
    */
    customerInTransit(requestParameters: shipmentApiParams.CustomerInTransitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Delete Shipment
    * @summary Delete Shipment
    * @param {number} shipmentNumber Number of the shipment to be deleted. Cannot be empty.
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    deleteShipmentRaw(requestParameters: shipmentApiParams.DeleteShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
    * Delete Shipment
    * Delete Shipment
    */
    deleteShipment(requestParameters: shipmentApiParams.DeleteShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
    * Delete Shipments from Order
    * @summary Delete Shipments from Order
    * @param {string} orderId Unique identifier of the order to delete shipments from. Cannot be empty.
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    deleteShipmentsOfOrderRaw(requestParameters: shipmentApiParams.DeleteShipmentsOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
    * Delete Shipments from Order
    * Delete Shipments from Order
    */
    deleteShipmentsOfOrder(requestParameters: shipmentApiParams.DeleteShipmentsOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
    * Update Destination
    * @summary Update Destination
    * @param {number} shipmentNumber 
    * @param {DestinationDto} destinationDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    destinationUpdateRaw(requestParameters: shipmentApiParams.DestinationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Update Destination
    * Update Destination
    */
    destinationUpdate(requestParameters: shipmentApiParams.DestinationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Complete Workflow Task
    * @summary Complete Workflow Task
    * @param {number} shipmentNumber 
    * @param {string} taskName 
    * @param {TaskCompleteDto} taskCompleteDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    executeRaw(requestParameters: shipmentApiParams.ExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Complete Workflow Task
    * Complete Workflow Task
    */
    execute(requestParameters: shipmentApiParams.ExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Fulfill Shipment
    * @summary Fulfill Shipment
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    fulfillShipmentRaw(requestParameters: shipmentApiParams.FulfillShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Fulfill Shipment
    * Fulfill Shipment
    */
    fulfillShipment(requestParameters: shipmentApiParams.FulfillShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Get Location Summary Report
    * @summary Get Location Summary Report
    * @param {Array<string>} locationCodes 
    * @param {string} startDateTime 
    * @param {boolean} [bypassSearchIndex] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    getLocationSummaryReportRaw(requestParameters: shipmentApiParams.GetLocationSummaryReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelLocationSummaryDto>>;

    /**
    * Get Location Summary Report
    * Get Location Summary Report
    */
    getLocationSummaryReport(requestParameters: shipmentApiParams.GetLocationSummaryReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelLocationSummaryDto>;

    /**
    * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
    * @summary Get Shipment
    * @param {number} shipmentNumber 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    getShipmentRaw(requestParameters: shipmentApiParams.GetShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
    * Get Shipment
    */
    getShipment(requestParameters: shipmentApiParams.GetShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Get Workflow Task Counts
    * @summary Get Workflow Task Counts
    * @param {string} shipmentType 
    * @param {Array<string>} [assignedLocations] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    getShipmentStepCountByShipmentTypeRaw(requestParameters: shipmentApiParams.GetShipmentStepCountByShipmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelDashboardResponseDto>>;

    /**
    * Get Workflow Task Counts
    * Get Workflow Task Counts
    */
    getShipmentStepCountByShipmentType(requestParameters: shipmentApiParams.GetShipmentStepCountByShipmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelDashboardResponseDto>;

    /**
    * A paged list of shipments is returned according to any specified filter criteria and sort options
    * @summary Get Shipments
    * @param {GetShipmentsRequest} request Shipment request.
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    getShipmentsRaw(requestParameters: shipmentApiParams.GetShipmentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PagedModelEntityModelShipmentDto>>;

    /**
    * A paged list of shipments is returned according to any specified filter criteria and sort options
    * Get Shipments
    */
    getShipments(requestParameters: shipmentApiParams.GetShipmentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PagedModelEntityModelShipmentDto>;

    /**
    * Get Workflow Tasks
    * @summary Get Workflow Tasks
    * @param {number} shipmentNumber Number of the shipment to be searched. Cannot be empty.
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    getTasksRaw(requestParameters: shipmentApiParams.GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TaskDto>>>;

    /**
    * Get Workflow Tasks
    * Get Workflow Tasks
    */
    getTasks(requestParameters: shipmentApiParams.GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TaskDto>>;

    /**
    * Shipment Items Ready for Preparation
    * @summary Shipment Items Ready for Preparation
    * @param {number} shipmentNumber 
    * @param {ReadyForPrepItemsRequestDto} readyForPrepItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    itemsReadyForPrepRaw(requestParameters: shipmentApiParams.ItemsReadyForPrepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Shipment Items Ready for Preparation
    * Shipment Items Ready for Preparation
    */
    itemsReadyForPrep(requestParameters: shipmentApiParams.ItemsReadyForPrepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Create Shipment
    * @summary Create Shipment
    * @param {ShipmentDto} shipmentDto 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    newShipmentRaw(requestParameters: shipmentApiParams.NewShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShipmentDto>>;

    /**
    * Create Shipment
    * Create Shipment
    */
    newShipment(requestParameters: shipmentApiParams.NewShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShipmentDto>;

    /**
    * Bulk Create Shipments
    * @summary Bulk Create Shipments
    * @param {Array<ShipmentDto>} shipmentDto 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    newShipmentsRaw(requestParameters: shipmentApiParams.NewShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelEntityModelShipmentDto>>;

    /**
    * Bulk Create Shipments
    * Bulk Create Shipments
    */
    newShipments(requestParameters: shipmentApiParams.NewShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelEntityModelShipmentDto>;

    /**
    * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
    * @summary Pickup Items
    * @param {number} shipmentNumber 
    * @param {PickupItemsRequestDto} pickupItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    pickupItemsRaw(requestParameters: shipmentApiParams.PickupItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
    * Pickup Items
    */
    pickupItems(requestParameters: shipmentApiParams.PickupItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
    * @summary Reassign Items
    * @param {number} shipmentNumber 
    * @param {ReassignItemsRequestDto} reassignItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    reassignItemsRaw(requestParameters: shipmentApiParams.ReassignItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
    * Reassign Items
    */
    reassignItems(requestParameters: shipmentApiParams.ReassignItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
    * @summary Reassign Shipment
    * @param {number} shipmentNumber 
    * @param {ReassignShipmentRequestDto} reassignShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    reassignShipmentRaw(requestParameters: shipmentApiParams.ReassignShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
    * Reassign Shipment
    */
    reassignShipment(requestParameters: shipmentApiParams.ReassignShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
    * @summary Receive Transfer
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    receiveTransferRaw(requestParameters: shipmentApiParams.ReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
    * Receive Transfer
    */
    receiveTransfer(requestParameters: shipmentApiParams.ReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Refresh Shipment
    * @summary Refresh Shipment
    * @param {number} shipmentNumber 
    * @param {boolean} [shouldLog] 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    refreshShipmentRaw(requestParameters: shipmentApiParams.RefreshShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Refresh Shipment
    * Refresh Shipment
    */
    refreshShipment(requestParameters: shipmentApiParams.RefreshShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
    * @summary Reject Items
    * @param {number} shipmentNumber 
    * @param {RejectItemsRequestDto} rejectItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    rejectItemsRaw(requestParameters: shipmentApiParams.RejectItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
    * Reject Items
    */
    rejectItems(requestParameters: shipmentApiParams.RejectItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
    * @summary Reject Shipment
    * @param {number} shipmentNumber 
    * @param {RejectShipmentRequestDto} rejectShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    rejectShipmentRaw(requestParameters: shipmentApiParams.RejectShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
    * Reject Shipment
    */
    rejectShipment(requestParameters: shipmentApiParams.RejectShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Render order summary by shipment number in HTML format for printing
    * @summary Render Order Summary by Shipment Number
    * @param {number} shipmentNumber 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    renderOrderSummaryRaw(requestParameters: shipmentApiParams.RenderOrderSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelRenderedContentDto>>;

    /**
    * Render order summary by shipment number in HTML format for printing
    * Render Order Summary by Shipment Number
    */
    renderOrderSummary(requestParameters: shipmentApiParams.RenderOrderSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelRenderedContentDto>;

    /**
    * Render shipment packing slip in HTML format for printing
    * @summary Render Shipment Packing Slip
    * @param {number} shipmentNumber 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    renderPackingSlipRaw(requestParameters: shipmentApiParams.RenderPackingSlipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelRenderedContentDto>>;

    /**
    * Render shipment packing slip in HTML format for printing
    * Render Shipment Packing Slip
    */
    renderPackingSlip(requestParameters: shipmentApiParams.RenderPackingSlipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelRenderedContentDto>;

    /**
    * Update Shipment
    * @summary Update Shipment
    * @param {number} shipmentNumber Number of the shipment to update. Cannot be empty.
    * @param {ShipmentDto} shipmentDto 
    * @param {Array<string>} [updateFields] List of shipment fields to update.
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    replaceShipmentRaw(requestParameters: shipmentApiParams.ReplaceShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Update Shipment
    * Update Shipment
    */
    replaceShipment(requestParameters: shipmentApiParams.ReplaceShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Resend Item Email
    * @summary Resend Item Email
    * @param {number} shipmentNumber 
    * @param {number} lineId 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    resendItemEmailRaw(requestParameters: shipmentApiParams.ResendItemEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
    * Resend Item Email
    * Resend Item Email
    */
    resendItemEmail(requestParameters: shipmentApiParams.ResendItemEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
    * Resend Shipment Email
    * @summary Resend Shipment Email
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    resendShipmentEmailRaw(requestParameters: shipmentApiParams.ResendShipmentEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
    * Resend Shipment Email
    * Resend Shipment Email
    */
    resendShipmentEmail(requestParameters: shipmentApiParams.ResendShipmentEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
    * Retry Fulfilling Shipment
    * @summary Retry Fulfilling Shipment
    * @param {number} shipmentNumber 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    retryFulfillingShipmentRaw(requestParameters: shipmentApiParams.RetryFulfillingShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Retry Fulfilling Shipment
    * Retry Fulfilling Shipment
    */
    retryFulfillingShipment(requestParameters: shipmentApiParams.RetryFulfillingShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Revert Workflow Task
    * @summary Revert Workflow Task
    * @param {number} shipmentNumber 
    * @param {string} taskName 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    revertRaw(requestParameters: shipmentApiParams.RevertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Revert Workflow Task
    * Revert Workflow Task
    */
    revert(requestParameters: shipmentApiParams.RevertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Find and Receive Transfer
    * @summary Find and Receive Transfer
    * @param {string} search 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    searchAndReceiveTransferRaw(requestParameters: shipmentApiParams.SearchAndReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Find and Receive Transfer
    * Find and Receive Transfer
    */
    searchAndReceiveTransfer(requestParameters: shipmentApiParams.SearchAndReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Find Receivable Transfer Shipments
    * @summary Find Receivable Transfer Shipments
    * @param {string} search 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    searchReceivableShipmentRaw(requestParameters: shipmentApiParams.SearchReceivableShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Find Receivable Transfer Shipments
    * Find Receivable Transfer Shipments
    */
    searchReceivableShipment(requestParameters: shipmentApiParams.SearchReceivableShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Skip Workflow Task
    * @summary Skip Workflow Task
    * @param {number} shipmentNumber 
    * @param {string} taskName 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    skipTaskRaw(requestParameters: shipmentApiParams.SkipTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Skip Workflow Task
    * Skip Workflow Task
    */
    skipTask(requestParameters: shipmentApiParams.SkipTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
    * @summary Transfer Items
    * @param {number} shipmentNumber 
    * @param {TransferItemsRequestDto} transferItemsRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    transferItemsRaw(requestParameters: shipmentApiParams.TransferItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
    * Transfer Items
    */
    transferItems(requestParameters: shipmentApiParams.TransferItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
    * @summary Transfer Shipment
    * @param {number} shipmentNumber 
    * @param {TransferShipmentRequestDto} transferShipmentRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    transferShipmentRaw(requestParameters: shipmentApiParams.TransferShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
    * Transfer Shipment
    */
    transferShipment(requestParameters: shipmentApiParams.TransferShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Update Fulfillment Fields
    * @summary Update Fulfillment Fields
    * @param {number} shipmentNumber 
    * @param {Array<ItemDto>} itemDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    updateFulfillmentFieldsRaw(requestParameters: shipmentApiParams.UpdateFulfillmentFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Update Fulfillment Fields
    * Update Fulfillment Fields
    */
    updateFulfillmentFields(requestParameters: shipmentApiParams.UpdateFulfillmentFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Update Gift Card Info
    * @summary Update Gift Card Info
    * @param {number} shipmentNumber 
    * @param {GiftCardInfoRequestDto} giftCardInfoRequestDto 
    * @param {string} [ifMatch] 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    updateGiftCardInfoRaw(requestParameters: shipmentApiParams.UpdateGiftCardInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>>;

    /**
    * Update Gift Card Info
    * Update Gift Card Info
    */
    updateGiftCardInfo(requestParameters: shipmentApiParams.UpdateGiftCardInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto>;

    /**
    * Get Workflow Definition Image
    * @summary Get Workflow Definition Image
    * @param {number} shipmentNumber 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    workflowDefinitionImageRaw(requestParameters: shipmentApiParams.WorkflowDefinitionImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
    * Get Workflow Definition Image
    * Get Workflow Definition Image
    */
    workflowDefinitionImage(requestParameters: shipmentApiParams.WorkflowDefinitionImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
    * Get Workflow Instance Image
    * @summary Get Workflow Instance Image
    * @param {number} shipmentNumber 
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof ShipmentApiInterface
    */
    workflowInstanceImageRaw(requestParameters: shipmentApiParams.WorkflowInstanceImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
    * Get Workflow Instance Image
    * Get Workflow Instance Image
    */
    workflowInstanceImage(requestParameters: shipmentApiParams.WorkflowInstanceImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

}


/**
 * 
 */
export class ShipmentApi extends runtime.BaseAPI implements ShipmentApiService {
    constructor(configuration?) {
        super(configuration)
        this.basePathTemplate = basePathTemplate
    }
    /**
     * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
     * Backorder Items
     */


    async backorderItemsRaw(requestParameters: shipmentApiParams.BackorderItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderItems.');
        }

        if (requestParameters.backorderItemsRequestDto === null || requestParameters.backorderItemsRequestDto === undefined) {
            throw new runtime.RequiredError('backorderItemsRequestDto','Required parameter requestParameters.backorderItemsRequestDto was null or undefined when calling backorderItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backorderedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.backorderItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
     * Backorder Items
     */
    async backorderItems(requestParameters: shipmentApiParams.BackorderItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.backorderItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
     * Backorder Items Update
     */


    async backorderItemsUpdateRaw(requestParameters: shipmentApiParams.BackorderItemsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderItemsUpdate.');
        }

        if (requestParameters.backorderItemsUpdateRequestDto === null || requestParameters.backorderItemsUpdateRequestDto === undefined) {
            throw new runtime.RequiredError('backorderItemsUpdateRequestDto','Required parameter requestParameters.backorderItemsUpdateRequestDto was null or undefined when calling backorderItemsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backorderedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.backorderItemsUpdateRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
     * Backorder Items Update
     */
    async backorderItemsUpdate(requestParameters: shipmentApiParams.BackorderItemsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.backorderItemsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
     * Backorder Shipment
     */


    async backorderShipmentRaw(requestParameters: shipmentApiParams.BackorderShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderShipment.');
        }

        if (requestParameters.backorderShipmentRequestDto === null || requestParameters.backorderShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('backorderShipmentRequestDto','Required parameter requestParameters.backorderShipmentRequestDto was null or undefined when calling backorderShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backordered`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.backorderShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
     * Backorder Shipment
     */
    async backorderShipment(requestParameters: shipmentApiParams.BackorderShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.backorderShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Items
     * Cancel Items
     */


    async cancelItemsRaw(requestParameters: shipmentApiParams.CancelItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling cancelItems.');
        }

        if (requestParameters.cancelItemsRequestDto === null || requestParameters.cancelItemsRequestDto === undefined) {
            throw new runtime.RequiredError('cancelItemsRequestDto','Required parameter requestParameters.cancelItemsRequestDto was null or undefined when calling cancelItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/canceledItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.cancelItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Cancel Items
     * Cancel Items
     */
    async cancelItems(requestParameters: shipmentApiParams.CancelItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.cancelItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Shipment
     * Cancel Shipment
     */


    async cancelShipmentRaw(requestParameters: shipmentApiParams.CancelShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling cancelShipment.');
        }

        if (requestParameters.cancelShipmentRequestDto === null || requestParameters.cancelShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('cancelShipmentRequestDto','Required parameter requestParameters.cancelShipmentRequestDto was null or undefined when calling cancelShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/canceled`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.cancelShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Cancel Shipment
     * Cancel Shipment
     */
    async cancelShipment(requestParameters: shipmentApiParams.CancelShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.cancelShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Shipments
     * Cancel Shipments
     */


    async cancelShipmentsRaw(requestParameters: shipmentApiParams.CancelShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelShipmentDto>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling cancelShipments.');
        }

        if (requestParameters.cancelShipmentRequestDto === null || requestParameters.cancelShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('cancelShipmentRequestDto','Required parameter requestParameters.cancelShipmentRequestDto was null or undefined when calling cancelShipments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/order/{orderId}/canceled`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.cancelShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Cancel Shipments
     * Cancel Shipments
     */
    async cancelShipments(requestParameters: shipmentApiParams.CancelShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelShipmentDto> {
        const response = await this.cancelShipmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that a customer has arrived for curbside pickup of this shipment.
     * Customer At Curbside
     */


    async customerAtCurbsideRaw(requestParameters: shipmentApiParams.CustomerAtCurbsideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerAtCurbside.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling customerAtCurbside.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerAtCurbside`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Indicate that a customer has arrived for curbside pickup of this shipment.
     * Customer At Curbside
     */
    async customerAtCurbside(requestParameters: shipmentApiParams.CustomerAtCurbsideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.customerAtCurbsideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that the customer has arrived for store pickup of this shipment.
     * Customer At Store
     */


    async customerAtStoreRaw(requestParameters: shipmentApiParams.CustomerAtStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerAtStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerAtStore`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Indicate that the customer has arrived for store pickup of this shipment.
     * Customer At Store
     */
    async customerAtStore(requestParameters: shipmentApiParams.CustomerAtStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.customerAtStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send items to Customer Care
     * Customer Care Items
     */


    async customerCareItemsRaw(requestParameters: shipmentApiParams.CustomerCareItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerCareItems.');
        }

        if (requestParameters.rejectItemsRequestDto === null || requestParameters.rejectItemsRequestDto === undefined) {
            throw new runtime.RequiredError('rejectItemsRequestDto','Required parameter requestParameters.rejectItemsRequestDto was null or undefined when calling customerCareItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerCaredItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.rejectItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Send items to Customer Care
     * Customer Care Items
     */
    async customerCareItems(requestParameters: shipmentApiParams.CustomerCareItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.customerCareItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send a shipment to Customer Care
     * Customer Care Shipment
     */


    async customerCareShipmentRaw(requestParameters: shipmentApiParams.CustomerCareShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerCareShipment.');
        }

        if (requestParameters.rejectShipmentRequestDto === null || requestParameters.rejectShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('rejectShipmentRequestDto','Required parameter requestParameters.rejectShipmentRequestDto was null or undefined when calling customerCareShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerCared`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.rejectShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Send a shipment to Customer Care
     * Customer Care Shipment
     */
    async customerCareShipment(requestParameters: shipmentApiParams.CustomerCareShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.customerCareShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that a customer is on their way to the store for curbside delivery.
     * Customer In Transit
     */


    async customerInTransitRaw(requestParameters: shipmentApiParams.CustomerInTransitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerInTransit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerInTransit`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Indicate that a customer is on their way to the store for curbside delivery.
     * Customer In Transit
     */
    async customerInTransit(requestParameters: shipmentApiParams.CustomerInTransitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.customerInTransitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Shipment
     * Delete Shipment
     */


    async deleteShipmentRaw(requestParameters: shipmentApiParams.DeleteShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling deleteShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Shipment
     * Delete Shipment
     */
    async deleteShipment(requestParameters: shipmentApiParams.DeleteShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteShipmentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Shipments from Order
     * Delete Shipments from Order
     */


    async deleteShipmentsOfOrderRaw(requestParameters: shipmentApiParams.DeleteShipmentsOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling deleteShipmentsOfOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/order/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Shipments from Order
     * Delete Shipments from Order
     */
    async deleteShipmentsOfOrder(requestParameters: shipmentApiParams.DeleteShipmentsOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteShipmentsOfOrderRaw(requestParameters, initOverrides);
    }

    /**
     * Update Destination
     * Update Destination
     */


    async destinationUpdateRaw(requestParameters: shipmentApiParams.DestinationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling destinationUpdate.');
        }

        if (requestParameters.destinationDto === null || requestParameters.destinationDto === undefined) {
            throw new runtime.RequiredError('destinationDto','Required parameter requestParameters.destinationDto was null or undefined when calling destinationUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/destination`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.destinationDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Destination
     * Update Destination
     */
    async destinationUpdate(requestParameters: shipmentApiParams.DestinationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.destinationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Complete Workflow Task
     * Complete Workflow Task
     */


    async executeRaw(requestParameters: shipmentApiParams.ExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling execute.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling execute.');
        }

        if (requestParameters.taskCompleteDto === null || requestParameters.taskCompleteDto === undefined) {
            throw new runtime.RequiredError('taskCompleteDto','Required parameter requestParameters.taskCompleteDto was null or undefined when calling execute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/completed`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.taskCompleteDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Complete Workflow Task
     * Complete Workflow Task
     */
    async execute(requestParameters: shipmentApiParams.ExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.executeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fulfill Shipment
     * Fulfill Shipment
     */


    async fulfillShipmentRaw(requestParameters: shipmentApiParams.FulfillShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling fulfillShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/fulfilled`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fulfill Shipment
     * Fulfill Shipment
     */
    async fulfillShipment(requestParameters: shipmentApiParams.FulfillShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.fulfillShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Location Summary Report
     * Get Location Summary Report
     */


    async getLocationSummaryReportRaw(requestParameters: shipmentApiParams.GetLocationSummaryReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelLocationSummaryDto>> {
        if (requestParameters.locationCodes === null || requestParameters.locationCodes === undefined) {
            throw new runtime.RequiredError('locationCodes','Required parameter requestParameters.locationCodes was null or undefined when calling getLocationSummaryReport.');
        }

        if (requestParameters.startDateTime === null || requestParameters.startDateTime === undefined) {
            throw new runtime.RequiredError('startDateTime','Required parameter requestParameters.startDateTime was null or undefined when calling getLocationSummaryReport.');
        }

        const queryParameters: any = {};

        if (requestParameters.locationCodes) {
            queryParameters['locationCodes'] = requestParameters.locationCodes;
        }

        if (requestParameters.startDateTime !== undefined) {
            queryParameters['startDateTime'] = requestParameters.startDateTime;
        }

        if (requestParameters.bypassSearchIndex !== undefined) {
            queryParameters['bypassSearchIndex'] = requestParameters.bypassSearchIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/locationSummaryReport`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get Location Summary Report
     * Get Location Summary Report
     */
    async getLocationSummaryReport(requestParameters: shipmentApiParams.GetLocationSummaryReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelLocationSummaryDto> {
        const response = await this.getLocationSummaryReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
     * Get Shipment
     */


    async getShipmentRaw(requestParameters: shipmentApiParams.GetShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling getShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
     * Get Shipment
     */
    async getShipment(requestParameters: shipmentApiParams.GetShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.getShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Task Counts
     * Get Workflow Task Counts
     */


    async getShipmentStepCountByShipmentTypeRaw(requestParameters: shipmentApiParams.GetShipmentStepCountByShipmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelDashboardResponseDto>> {
        if (requestParameters.shipmentType === null || requestParameters.shipmentType === undefined) {
            throw new runtime.RequiredError('shipmentType','Required parameter requestParameters.shipmentType was null or undefined when calling getShipmentStepCountByShipmentType.');
        }

        const queryParameters: any = {};

        if (requestParameters.shipmentType !== undefined) {
            queryParameters['shipmentType'] = requestParameters.shipmentType;
        }

        if (requestParameters.assignedLocations) {
            queryParameters['assignedLocations'] = requestParameters.assignedLocations;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/countsByStep`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get Workflow Task Counts
     * Get Workflow Task Counts
     */
    async getShipmentStepCountByShipmentType(requestParameters: shipmentApiParams.GetShipmentStepCountByShipmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelDashboardResponseDto> {
        const response = await this.getShipmentStepCountByShipmentTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A paged list of shipments is returned according to any specified filter criteria and sort options
     * Get Shipments
     */


    async getShipmentsRaw(requestParameters: shipmentApiParams.GetShipmentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PagedModelEntityModelShipmentDto>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling getShipments.');
        }

        const queryParameters: any = {};

        if (requestParameters.request !== undefined) {
            queryParameters['request'] = requestParameters.request;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * A paged list of shipments is returned according to any specified filter criteria and sort options
     * Get Shipments
     */
    async getShipments(requestParameters: shipmentApiParams.GetShipmentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PagedModelEntityModelShipmentDto> {
        const response = await this.getShipmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Tasks
     * Get Workflow Tasks
     */


    async getTasksRaw(requestParameters: shipmentApiParams.GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TaskDto>>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling getTasks.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get Workflow Tasks
     * Get Workflow Tasks
     */
    async getTasks(requestParameters: shipmentApiParams.GetTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TaskDto>> {
        const response = await this.getTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Shipment Items Ready for Preparation
     * Shipment Items Ready for Preparation
     */


    async itemsReadyForPrepRaw(requestParameters: shipmentApiParams.ItemsReadyForPrepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling itemsReadyForPrep.');
        }

        if (requestParameters.readyForPrepItemsRequestDto === null || requestParameters.readyForPrepItemsRequestDto === undefined) {
            throw new runtime.RequiredError('readyForPrepItemsRequestDto','Required parameter requestParameters.readyForPrepItemsRequestDto was null or undefined when calling itemsReadyForPrep.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/itemsReadyForPrep`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.readyForPrepItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Shipment Items Ready for Preparation
     * Shipment Items Ready for Preparation
     */
    async itemsReadyForPrep(requestParameters: shipmentApiParams.ItemsReadyForPrepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.itemsReadyForPrepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Shipment
     * Create Shipment
     */


    async newShipmentRaw(requestParameters: shipmentApiParams.NewShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShipmentDto>> {
        if (requestParameters.shipmentDto === null || requestParameters.shipmentDto === undefined) {
            throw new runtime.RequiredError('shipmentDto','Required parameter requestParameters.shipmentDto was null or undefined when calling newShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.shipmentDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create Shipment
     * Create Shipment
     */
    async newShipment(requestParameters: shipmentApiParams.NewShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShipmentDto> {
        const response = await this.newShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk Create Shipments
     * Bulk Create Shipments
     */


    async newShipmentsRaw(requestParameters: shipmentApiParams.NewShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelEntityModelShipmentDto>> {
        if (requestParameters.shipmentDto === null || requestParameters.shipmentDto === undefined) {
            throw new runtime.RequiredError('shipmentDto','Required parameter requestParameters.shipmentDto was null or undefined when calling newShipments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.shipmentDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Bulk Create Shipments
     * Bulk Create Shipments
     */
    async newShipments(requestParameters: shipmentApiParams.NewShipmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelEntityModelShipmentDto> {
        const response = await this.newShipmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
     * Pickup Items
     */


    async pickupItemsRaw(requestParameters: shipmentApiParams.PickupItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling pickupItems.');
        }

        if (requestParameters.pickupItemsRequestDto === null || requestParameters.pickupItemsRequestDto === undefined) {
            throw new runtime.RequiredError('pickupItemsRequestDto','Required parameter requestParameters.pickupItemsRequestDto was null or undefined when calling pickupItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/pickedUpItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.pickupItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
     * Pickup Items
     */
    async pickupItems(requestParameters: shipmentApiParams.PickupItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.pickupItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
     * Reassign Items
     */


    async reassignItemsRaw(requestParameters: shipmentApiParams.ReassignItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling reassignItems.');
        }

        if (requestParameters.reassignItemsRequestDto === null || requestParameters.reassignItemsRequestDto === undefined) {
            throw new runtime.RequiredError('reassignItemsRequestDto','Required parameter requestParameters.reassignItemsRequestDto was null or undefined when calling reassignItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/reassignedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reassignItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
     * Reassign Items
     */
    async reassignItems(requestParameters: shipmentApiParams.ReassignItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.reassignItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
     * Reassign Shipment
     */


    async reassignShipmentRaw(requestParameters: shipmentApiParams.ReassignShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling reassignShipment.');
        }

        if (requestParameters.reassignShipmentRequestDto === null || requestParameters.reassignShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('reassignShipmentRequestDto','Required parameter requestParameters.reassignShipmentRequestDto was null or undefined when calling reassignShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/reassigned`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reassignShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
     * Reassign Shipment
     */
    async reassignShipment(requestParameters: shipmentApiParams.ReassignShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.reassignShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
     * Receive Transfer
     */


    async receiveTransferRaw(requestParameters: shipmentApiParams.ReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling receiveTransfer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/received`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
     * Receive Transfer
     */
    async receiveTransfer(requestParameters: shipmentApiParams.ReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.receiveTransferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refresh Shipment
     * Refresh Shipment
     */


    async refreshShipmentRaw(requestParameters: shipmentApiParams.RefreshShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling refreshShipment.');
        }

        const queryParameters: any = {};

        if (requestParameters.shouldLog !== undefined) {
            queryParameters['shouldLog'] = requestParameters.shouldLog;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/refresh`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Refresh Shipment
     * Refresh Shipment
     */
    async refreshShipment(requestParameters: shipmentApiParams.RefreshShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.refreshShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
     * Reject Items
     */


    async rejectItemsRaw(requestParameters: shipmentApiParams.RejectItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling rejectItems.');
        }

        if (requestParameters.rejectItemsRequestDto === null || requestParameters.rejectItemsRequestDto === undefined) {
            throw new runtime.RequiredError('rejectItemsRequestDto','Required parameter requestParameters.rejectItemsRequestDto was null or undefined when calling rejectItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rejectedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.rejectItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
     * Reject Items
     */
    async rejectItems(requestParameters: shipmentApiParams.RejectItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.rejectItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
     * Reject Shipment
     */


    async rejectShipmentRaw(requestParameters: shipmentApiParams.RejectShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling rejectShipment.');
        }

        if (requestParameters.rejectShipmentRequestDto === null || requestParameters.rejectShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('rejectShipmentRequestDto','Required parameter requestParameters.rejectShipmentRequestDto was null or undefined when calling rejectShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rejected`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.rejectShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
     * Reject Shipment
     */
    async rejectShipment(requestParameters: shipmentApiParams.RejectShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.rejectShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Render order summary by shipment number in HTML format for printing
     * Render Order Summary by Shipment Number
     */


    async renderOrderSummaryRaw(requestParameters: shipmentApiParams.RenderOrderSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelRenderedContentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling renderOrderSummary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/order-summary/html`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Render order summary by shipment number in HTML format for printing
     * Render Order Summary by Shipment Number
     */
    async renderOrderSummary(requestParameters: shipmentApiParams.RenderOrderSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelRenderedContentDto> {
        const response = await this.renderOrderSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Render shipment packing slip in HTML format for printing
     * Render Shipment Packing Slip
     */


    async renderPackingSlipRaw(requestParameters: shipmentApiParams.RenderPackingSlipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelRenderedContentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling renderPackingSlip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rendition/html`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Render shipment packing slip in HTML format for printing
     * Render Shipment Packing Slip
     */
    async renderPackingSlip(requestParameters: shipmentApiParams.RenderPackingSlipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelRenderedContentDto> {
        const response = await this.renderPackingSlipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Shipment
     * Update Shipment
     */


    async replaceShipmentRaw(requestParameters: shipmentApiParams.ReplaceShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling replaceShipment.');
        }

        if (requestParameters.shipmentDto === null || requestParameters.shipmentDto === undefined) {
            throw new runtime.RequiredError('shipmentDto','Required parameter requestParameters.shipmentDto was null or undefined when calling replaceShipment.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateFields) {
            queryParameters['updateFields'] = requestParameters.updateFields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.shipmentDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Shipment
     * Update Shipment
     */
    async replaceShipment(requestParameters: shipmentApiParams.ReplaceShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.replaceShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resend Item Email
     * Resend Item Email
     */


    async resendItemEmailRaw(requestParameters: shipmentApiParams.ResendItemEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling resendItemEmail.');
        }

        if (requestParameters.lineId === null || requestParameters.lineId === undefined) {
            throw new runtime.RequiredError('lineId','Required parameter requestParameters.lineId was null or undefined when calling resendItemEmail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/items/{lineId}/email/resend`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"lineId"}}`, encodeURIComponent(String(requestParameters.lineId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resend Item Email
     * Resend Item Email
     */
    async resendItemEmail(requestParameters: shipmentApiParams.ResendItemEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resendItemEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Resend Shipment Email
     * Resend Shipment Email
     */


    async resendShipmentEmailRaw(requestParameters: shipmentApiParams.ResendShipmentEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling resendShipmentEmail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/email/resend`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resend Shipment Email
     * Resend Shipment Email
     */
    async resendShipmentEmail(requestParameters: shipmentApiParams.ResendShipmentEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resendShipmentEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Retry Fulfilling Shipment
     * Retry Fulfilling Shipment
     */


    async retryFulfillingShipmentRaw(requestParameters: shipmentApiParams.RetryFulfillingShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling retryFulfillingShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/retried`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retry Fulfilling Shipment
     * Retry Fulfilling Shipment
     */
    async retryFulfillingShipment(requestParameters: shipmentApiParams.RetryFulfillingShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.retryFulfillingShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revert Workflow Task
     * Revert Workflow Task
     */


    async revertRaw(requestParameters: shipmentApiParams.RevertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling revert.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling revert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/reverted`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Revert Workflow Task
     * Revert Workflow Task
     */
    async revert(requestParameters: shipmentApiParams.RevertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.revertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and Receive Transfer
     * Find and Receive Transfer
     */


    async searchAndReceiveTransferRaw(requestParameters: shipmentApiParams.SearchAndReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchAndReceiveTransfer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/received/{search}`.replace(`{${"search"}}`, encodeURIComponent(String(requestParameters.search))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and Receive Transfer
     * Find and Receive Transfer
     */
    async searchAndReceiveTransfer(requestParameters: shipmentApiParams.SearchAndReceiveTransferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.searchAndReceiveTransferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find Receivable Transfer Shipments
     * Find Receivable Transfer Shipments
     */


    async searchReceivableShipmentRaw(requestParameters: shipmentApiParams.SearchReceivableShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchReceivableShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/receivable/{search}`.replace(`{${"search"}}`, encodeURIComponent(String(requestParameters.search))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find Receivable Transfer Shipments
     * Find Receivable Transfer Shipments
     */
    async searchReceivableShipment(requestParameters: shipmentApiParams.SearchReceivableShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.searchReceivableShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Skip Workflow Task
     * Skip Workflow Task
     */


    async skipTaskRaw(requestParameters: shipmentApiParams.SkipTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling skipTask.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling skipTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/skipped`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Skip Workflow Task
     * Skip Workflow Task
     */
    async skipTask(requestParameters: shipmentApiParams.SkipTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.skipTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
     * Transfer Items
     */


    async transferItemsRaw(requestParameters: shipmentApiParams.TransferItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling transferItems.');
        }

        if (requestParameters.transferItemsRequestDto === null || requestParameters.transferItemsRequestDto === undefined) {
            throw new runtime.RequiredError('transferItemsRequestDto','Required parameter requestParameters.transferItemsRequestDto was null or undefined when calling transferItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/transferredItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.transferItemsRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
     * Transfer Items
     */
    async transferItems(requestParameters: shipmentApiParams.TransferItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.transferItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
     * Transfer Shipment
     */


    async transferShipmentRaw(requestParameters: shipmentApiParams.TransferShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling transferShipment.');
        }

        if (requestParameters.transferShipmentRequestDto === null || requestParameters.transferShipmentRequestDto === undefined) {
            throw new runtime.RequiredError('transferShipmentRequestDto','Required parameter requestParameters.transferShipmentRequestDto was null or undefined when calling transferShipment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/transferred`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.transferShipmentRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
     * Transfer Shipment
     */
    async transferShipment(requestParameters: shipmentApiParams.TransferShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.transferShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Fulfillment Fields
     * Update Fulfillment Fields
     */


    async updateFulfillmentFieldsRaw(requestParameters: shipmentApiParams.UpdateFulfillmentFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling updateFulfillmentFields.');
        }

        if (requestParameters.itemDto === null || requestParameters.itemDto === undefined) {
            throw new runtime.RequiredError('itemDto','Required parameter requestParameters.itemDto was null or undefined when calling updateFulfillmentFields.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/fulfillmentFields`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.itemDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Fulfillment Fields
     * Update Fulfillment Fields
     */
    async updateFulfillmentFields(requestParameters: shipmentApiParams.UpdateFulfillmentFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.updateFulfillmentFieldsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Gift Card Info
     * Update Gift Card Info
     */


    async updateGiftCardInfoRaw(requestParameters: shipmentApiParams.UpdateGiftCardInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelShipmentDto>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling updateGiftCardInfo.');
        }

        if (requestParameters.giftCardInfoRequestDto === null || requestParameters.giftCardInfoRequestDto === undefined) {
            throw new runtime.RequiredError('giftCardInfoRequestDto','Required parameter requestParameters.giftCardInfoRequestDto was null or undefined when calling updateGiftCardInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/giftCardInfo`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.giftCardInfoRequestDto,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Gift Card Info
     * Update Gift Card Info
     */
    async updateGiftCardInfo(requestParameters: shipmentApiParams.UpdateGiftCardInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelShipmentDto> {
        const response = await this.updateGiftCardInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Definition Image
     * Get Workflow Definition Image
     */


    async workflowDefinitionImageRaw(requestParameters: shipmentApiParams.WorkflowDefinitionImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling workflowDefinitionImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/workflow-definition-image`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Workflow Definition Image
     * Get Workflow Definition Image
     */
    async workflowDefinitionImage(requestParameters: shipmentApiParams.WorkflowDefinitionImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.workflowDefinitionImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Instance Image
     * Get Workflow Instance Image
     */


    async workflowInstanceImageRaw(requestParameters: shipmentApiParams.WorkflowInstanceImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling workflowInstanceImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/workflow-instance-image`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Workflow Instance Image
     * Get Workflow Instance Image
     */
    async workflowInstanceImage(requestParameters: shipmentApiParams.WorkflowInstanceImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.workflowInstanceImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

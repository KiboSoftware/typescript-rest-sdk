/* tslint:disable */
/* eslint-disable */
/**
 * Kibo Fulfillment Service
 * OpenAPI Spec for Kibo Fulfillment Service
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../client-runtime';
import { basePathTemplate } from '../api-path';
import type {
  BackorderItemsRequest,
  BackorderItemsUpdateRequest,
  BackorderShipmentRequest,
  CancelItemsRequest,
  CancelShipment,
  CollectionModelOfEntityModelOfShipment,
  CollectionModelOfLocationSummary,
  CollectionModelOfShipment,
  CollectionModelOfTask,
  Destination,
  EntityModelOfDashboardResponse,
  EntityModelOfShipment,
  EntityModelOfstring,
  GiftCardInfoRequest,
  Item,
  PagedModelOfEntityModelOfShipment,
  PickupItemsRequest,
  ReassignItemsRequest,
  ReassignShipment,
  RejectItemsRequest,
  RejectShipment,
  Shipment,
  TaskComplete,
  TransferItemsRequest,
  TransferShipment,
} from '../models';
import {
    BackorderItemsRequestFromJSON,
    BackorderItemsRequestToJSON,
    BackorderItemsUpdateRequestFromJSON,
    BackorderItemsUpdateRequestToJSON,
    BackorderShipmentRequestFromJSON,
    BackorderShipmentRequestToJSON,
    CancelItemsRequestFromJSON,
    CancelItemsRequestToJSON,
    CancelShipmentFromJSON,
    CancelShipmentToJSON,
    CollectionModelOfEntityModelOfShipmentFromJSON,
    CollectionModelOfEntityModelOfShipmentToJSON,
    CollectionModelOfLocationSummaryFromJSON,
    CollectionModelOfLocationSummaryToJSON,
    CollectionModelOfShipmentFromJSON,
    CollectionModelOfShipmentToJSON,
    CollectionModelOfTaskFromJSON,
    CollectionModelOfTaskToJSON,
    DestinationFromJSON,
    DestinationToJSON,
    EntityModelOfDashboardResponseFromJSON,
    EntityModelOfDashboardResponseToJSON,
    EntityModelOfShipmentFromJSON,
    EntityModelOfShipmentToJSON,
    EntityModelOfstringFromJSON,
    EntityModelOfstringToJSON,
    GiftCardInfoRequestFromJSON,
    GiftCardInfoRequestToJSON,
    ItemFromJSON,
    ItemToJSON,
    PagedModelOfEntityModelOfShipmentFromJSON,
    PagedModelOfEntityModelOfShipmentToJSON,
    PickupItemsRequestFromJSON,
    PickupItemsRequestToJSON,
    ReassignItemsRequestFromJSON,
    ReassignItemsRequestToJSON,
    ReassignShipmentFromJSON,
    ReassignShipmentToJSON,
    RejectItemsRequestFromJSON,
    RejectItemsRequestToJSON,
    RejectShipmentFromJSON,
    RejectShipmentToJSON,
    ShipmentFromJSON,
    ShipmentToJSON,
    TaskCompleteFromJSON,
    TaskCompleteToJSON,
    TransferItemsRequestFromJSON,
    TransferItemsRequestToJSON,
    TransferShipmentFromJSON,
    TransferShipmentToJSON,
} from '../models';

export interface ShipmentApiBackorderItemsUpdateUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    backorderItemsUpdateRequest?: BackorderItemsUpdateRequest;
}

export interface ShipmentApiBackorderItemsUsingPOSTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    backorderItemsRequest?: BackorderItemsRequest;
}

export interface ShipmentApiBackorderShipmentUsingPOSTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    backorderShipmentRequest?: BackorderShipmentRequest;
}

export interface ShipmentApiCancelItemsUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    cancelItemsRequest?: CancelItemsRequest;
}

export interface ShipmentApiCancelShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    cancelShipment?: CancelShipment;
}

export interface ShipmentApiCancelShipmentsUsingPUTRequest {
    orderId: string;
    cancelShipment?: CancelShipment;
}

export interface ShipmentApiCustomerAtCurbsideUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    requestBody?: { [key: string]: object; };
}

export interface ShipmentApiCustomerAtStoreUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiCustomerCareItemsUsingPOSTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    rejectItemsRequest?: RejectItemsRequest;
}

export interface ShipmentApiCustomerCareShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    rejectShipment?: RejectShipment;
}

export interface ShipmentApiCustomerInTransitUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiDeleteShipmentUsingDELETERequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiDeleteShipmentsOfOrderUsingDELETERequest {
    orderId: string;
}

export interface ShipmentApiDestinationUpdateUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    destination?: Destination;
}

export interface ShipmentApiExecuteUsingPUTRequest {
    shipmentNumber: number;
    taskName: string;
    ifMatch?: string;
    taskComplete?: TaskComplete;
}

export interface ShipmentApiFulfillShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiGetLocationSummaryReportUsingGETRequest {
    locationCodes: string;
    startDateTime: Date;
    bypassSearchIndex?: boolean;
}

export interface ShipmentApiGetShipmentStepCountByShipmentTypeUsingGETRequest {
    shipmentType: string;
    assignedLocations?: string;
}

export interface ShipmentApiGetShipmentUsingGETRequest {
    shipmentNumber: number;
}

export interface ShipmentApiGetShipmentsUsingGETRequest {
    bypassSearchIndex?: boolean;
    filter?: string;
    isLate?: boolean;
    page?: number;
    pageSize?: number;
    quickSearch?: string;
    sort?: string;
    workflowTaskName?: string;
}

export interface ShipmentApiGetTasksUsingGETRequest {
    shipmentNumber: number;
}

export interface ShipmentApiNewShipmentUsingPOSTRequest {
    shipment?: Shipment;
}

export interface ShipmentApiNewShipmentsUsingPOSTRequest {
    shipment?: Array<Shipment>;
}

export interface ShipmentApiPickupItemsUsingPOSTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    pickupItemsRequest?: PickupItemsRequest;
}

export interface ShipmentApiReassignItemsUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    reassignItemsRequest?: ReassignItemsRequest;
}

export interface ShipmentApiReassignShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    reassignShipment?: ReassignShipment;
}

export interface ShipmentApiReceiveTransferUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiRefreshShipmentUsingPUTRequest {
    shipmentNumber: number;
    shouldLog?: boolean;
    ifMatch?: string;
}

export interface ShipmentApiRejectItemsUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    rejectItemsRequest?: RejectItemsRequest;
}

export interface ShipmentApiRejectShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    rejectShipment?: RejectShipment;
}

export interface ShipmentApiRenderOrderSummaryUsingGET1Request {
    shipmentNumber: number;
}

export interface ShipmentApiRenderPackingSlipUsingGETRequest {
    shipmentNumber: number;
}

export interface ShipmentApiReplaceShipmentUsingPUTRequest {
    shipmentNumber: number;
    updateFields?: string;
    ifMatch?: string;
    shipment?: Shipment;
}

export interface ShipmentApiResendItemEmailUsingPUTRequest {
    shipmentNumber: number;
    lineId: number;
    ifMatch?: string;
}

export interface ShipmentApiResendShipmentEmailUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiRetryFulfillingShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
}

export interface ShipmentApiRevertUsingPUTRequest {
    shipmentNumber: number;
    taskName: string;
    ifMatch?: string;
}

export interface ShipmentApiSearchAndReceiveTransferUsingPUTRequest {
    search: string;
    ifMatch?: string;
}

export interface ShipmentApiSkipTaskUsingPUTRequest {
    shipmentNumber: number;
    taskName: string;
    ifMatch?: string;
}

export interface ShipmentApiTransferItemsUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    transferItemsRequest?: TransferItemsRequest;
}

export interface ShipmentApiTransferShipmentUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    transferShipment?: TransferShipment;
}

export interface ShipmentApiUpdateFulfillmentFieldsUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    item?: Array<Item>;
}

export interface ShipmentApiUpdateGiftCardInfoUsingPUTRequest {
    shipmentNumber: number;
    ifMatch?: string;
    giftCardInfoRequest?: GiftCardInfoRequest;
}

export interface ShipmentApiWorkflowDefinitionImageUsingGETRequest {
    shipmentNumber: number;
}

export interface ShipmentApiWorkflowInstanceImageUsingGETRequest {
    shipmentNumber: number;
}

/**
 * 
 */
export class ShipmentApi extends runtime.BaseAPI {
    constructor(configuration?) {
        super(configuration)
        this.basePathTemplate = basePathTemplate
    }
    /**
     * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
     * Backorder Items Update
     */


    async backorderItemsUpdateUsingPUTRaw(requestParameters: ShipmentApiBackorderItemsUpdateUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderItemsUpdateUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backorderedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BackorderItemsUpdateRequestToJSON(requestParameters.backorderItemsUpdateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * When an item is in backorder, its expected release date can be modified to reflect any changes in inventory levels or manufacturing estimates. This should be kept up-to-date so that customer communications such as notification emails can accurately inform the customer about when their item is expected to be available or shipped.
     * Backorder Items Update
     */
    async backorderItemsUpdateUsingPUT(requestParameters: ShipmentApiBackorderItemsUpdateUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.backorderItemsUpdateUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
     * Backorder Items
     */


    async backorderItemsUsingPOSTRaw(requestParameters: ShipmentApiBackorderItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderItemsUsingPOST.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backorderedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BackorderItemsRequestToJSON(requestParameters.backorderItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * If a shipment is accepted by a location but some items of the shipment are temporarily out of stock, those particular items can be placed on backorder. These items will be placed into a pending Backorder state until inventory is in stock, at which point they are “released” from backorder to continue with the fulfillment process. This will not backorder the entire shipment, only the particular items waiting for inventory.
     * Backorder Items
     */
    async backorderItemsUsingPOST(requestParameters: ShipmentApiBackorderItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.backorderItemsUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
     * Backorder Shipment
     */


    async backorderShipmentUsingPOSTRaw(requestParameters: ShipmentApiBackorderShipmentUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling backorderShipmentUsingPOST.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/backordered`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BackorderShipmentRequestToJSON(requestParameters.backorderShipmentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * If a shipment is accepted by a location but the contents of the shipment are temporarily out of stock, the shipment can be placed on backorder. This means that the shipment will remain in the pending Backorder state while it waits for the inventory to be in stock, at which point it is “released” from backorder to continue with the fulfillment process.
     * Backorder Shipment
     */
    async backorderShipmentUsingPOST(requestParameters: ShipmentApiBackorderShipmentUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.backorderShipmentUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Items
     * Cancel Items
     */


    async cancelItemsUsingPUTRaw(requestParameters: ShipmentApiCancelItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling cancelItemsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/canceledItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CancelItemsRequestToJSON(requestParameters.cancelItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Cancel Items
     * Cancel Items
     */
    async cancelItemsUsingPUT(requestParameters: ShipmentApiCancelItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.cancelItemsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Shipment
     * Cancel Shipment
     */


    async cancelShipmentUsingPUTRaw(requestParameters: ShipmentApiCancelShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling cancelShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/canceled`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CancelShipmentToJSON(requestParameters.cancelShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Cancel Shipment
     * Cancel Shipment
     */
    async cancelShipmentUsingPUT(requestParameters: ShipmentApiCancelShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.cancelShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Shipments
     * Cancel Shipments
     */


    async cancelShipmentsUsingPUTRaw(requestParameters: ShipmentApiCancelShipmentsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelOfShipment>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling cancelShipmentsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/order/{orderId}/canceled`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CancelShipmentToJSON(requestParameters.cancelShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Cancel Shipments
     * Cancel Shipments
     */
    async cancelShipmentsUsingPUT(requestParameters: ShipmentApiCancelShipmentsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelOfShipment> {
        const response = await this.cancelShipmentsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that a customer has arrived for curbside pickup of this shipment.
     * Customer At Curbside
     */


    async customerAtCurbsideUsingPUTRaw(requestParameters: ShipmentApiCustomerAtCurbsideUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerAtCurbsideUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerAtCurbside`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Indicate that a customer has arrived for curbside pickup of this shipment.
     * Customer At Curbside
     */
    async customerAtCurbsideUsingPUT(requestParameters: ShipmentApiCustomerAtCurbsideUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.customerAtCurbsideUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that the customer has arrived for store pickup of this shipment.
     * Customer At Store
     */


    async customerAtStoreUsingPUTRaw(requestParameters: ShipmentApiCustomerAtStoreUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerAtStoreUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerAtStore`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Indicate that the customer has arrived for store pickup of this shipment.
     * Customer At Store
     */
    async customerAtStoreUsingPUT(requestParameters: ShipmentApiCustomerAtStoreUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.customerAtStoreUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send items to Customer Care
     * Customer Care Items
     */


    async customerCareItemsUsingPOSTRaw(requestParameters: ShipmentApiCustomerCareItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerCareItemsUsingPOST.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerCaredItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RejectItemsRequestToJSON(requestParameters.rejectItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Send items to Customer Care
     * Customer Care Items
     */
    async customerCareItemsUsingPOST(requestParameters: ShipmentApiCustomerCareItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.customerCareItemsUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send a shipment to Customer Care
     * Customer Care Shipment
     */


    async customerCareShipmentUsingPUTRaw(requestParameters: ShipmentApiCustomerCareShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerCareShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerCared`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RejectShipmentToJSON(requestParameters.rejectShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Send a shipment to Customer Care
     * Customer Care Shipment
     */
    async customerCareShipmentUsingPUT(requestParameters: ShipmentApiCustomerCareShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.customerCareShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Indicate that a customer is on their way to the store for curbside delivery.
     * Customer In Transit
     */


    async customerInTransitUsingPUTRaw(requestParameters: ShipmentApiCustomerInTransitUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling customerInTransitUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/customerInTransit`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Indicate that a customer is on their way to the store for curbside delivery.
     * Customer In Transit
     */
    async customerInTransitUsingPUT(requestParameters: ShipmentApiCustomerInTransitUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.customerInTransitUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Shipment
     * Delete Shipment
     */


    async deleteShipmentUsingDELETERaw(requestParameters: ShipmentApiDeleteShipmentUsingDELETERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling deleteShipmentUsingDELETE.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Shipment
     * Delete Shipment
     */
    async deleteShipmentUsingDELETE(requestParameters: ShipmentApiDeleteShipmentUsingDELETERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteShipmentUsingDELETERaw(requestParameters, initOverrides);
    }

    /**
     * Delete Shipments from Order
     * Delete Shipments from Order
     */


    async deleteShipmentsOfOrderUsingDELETERaw(requestParameters: ShipmentApiDeleteShipmentsOfOrderUsingDELETERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new runtime.RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling deleteShipmentsOfOrderUsingDELETE.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/order/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Shipments from Order
     * Delete Shipments from Order
     */
    async deleteShipmentsOfOrderUsingDELETE(requestParameters: ShipmentApiDeleteShipmentsOfOrderUsingDELETERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteShipmentsOfOrderUsingDELETERaw(requestParameters, initOverrides);
    }

    /**
     * Update Destination
     * Update Destination
     */


    async destinationUpdateUsingPUTRaw(requestParameters: ShipmentApiDestinationUpdateUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling destinationUpdateUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/destination`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DestinationToJSON(requestParameters.destination),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Update Destination
     * Update Destination
     */
    async destinationUpdateUsingPUT(requestParameters: ShipmentApiDestinationUpdateUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.destinationUpdateUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Complete Workflow Task
     * Complete Workflow Task
     */


    async executeUsingPUTRaw(requestParameters: ShipmentApiExecuteUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling executeUsingPUT.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling executeUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/completed`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TaskCompleteToJSON(requestParameters.taskComplete),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Complete Workflow Task
     * Complete Workflow Task
     */
    async executeUsingPUT(requestParameters: ShipmentApiExecuteUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.executeUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fulfill Shipment
     * Fulfill Shipment
     */


    async fulfillShipmentUsingPUTRaw(requestParameters: ShipmentApiFulfillShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling fulfillShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/fulfilled`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Fulfill Shipment
     * Fulfill Shipment
     */
    async fulfillShipmentUsingPUT(requestParameters: ShipmentApiFulfillShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.fulfillShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Location Summary Report
     * Get Location Summary Report
     */


    async getLocationSummaryReportUsingGETRaw(requestParameters: ShipmentApiGetLocationSummaryReportUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelOfLocationSummary>> {
        if (requestParameters.locationCodes === null || requestParameters.locationCodes === undefined) {
            throw new runtime.RequiredError('locationCodes','Required parameter requestParameters.locationCodes was null or undefined when calling getLocationSummaryReportUsingGET.');
        }

        if (requestParameters.startDateTime === null || requestParameters.startDateTime === undefined) {
            throw new runtime.RequiredError('startDateTime','Required parameter requestParameters.startDateTime was null or undefined when calling getLocationSummaryReportUsingGET.');
        }

        const queryParameters: any = {};

        if (requestParameters.locationCodes !== undefined) {
            queryParameters['locationCodes'] = requestParameters.locationCodes;
        }

        if (requestParameters.startDateTime !== undefined) {
            queryParameters['startDateTime'] = (requestParameters.startDateTime as any).toISOString();
        }

        if (requestParameters.bypassSearchIndex !== undefined) {
            queryParameters['bypassSearchIndex'] = requestParameters.bypassSearchIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/locationSummaryReport`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionModelOfLocationSummaryFromJSON(jsonValue));
    }

    /**
     * Get Location Summary Report
     * Get Location Summary Report
     */
    async getLocationSummaryReportUsingGET(requestParameters: ShipmentApiGetLocationSummaryReportUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelOfLocationSummary> {
        const response = await this.getLocationSummaryReportUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Task Counts
     * Get Workflow Task Counts
     */


    async getShipmentStepCountByShipmentTypeUsingGETRaw(requestParameters: ShipmentApiGetShipmentStepCountByShipmentTypeUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfDashboardResponse>> {
        if (requestParameters.shipmentType === null || requestParameters.shipmentType === undefined) {
            throw new runtime.RequiredError('shipmentType','Required parameter requestParameters.shipmentType was null or undefined when calling getShipmentStepCountByShipmentTypeUsingGET.');
        }

        const queryParameters: any = {};

        if (requestParameters.shipmentType !== undefined) {
            queryParameters['shipmentType'] = requestParameters.shipmentType;
        }

        if (requestParameters.assignedLocations !== undefined) {
            queryParameters['assignedLocations'] = requestParameters.assignedLocations;
        }

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/countsByStep`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfDashboardResponseFromJSON(jsonValue));
    }

    /**
     * Get Workflow Task Counts
     * Get Workflow Task Counts
     */
    async getShipmentStepCountByShipmentTypeUsingGET(requestParameters: ShipmentApiGetShipmentStepCountByShipmentTypeUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfDashboardResponse> {
        const response = await this.getShipmentStepCountByShipmentTypeUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
     * Get Shipment
     */


    async getShipmentUsingGETRaw(requestParameters: ShipmentApiGetShipmentUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling getShipmentUsingGET.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Get shipment information. Note that the schema supports both assignedLocationCode and fulfillmentLocationCode fields at the shipment level. These fields are usually be the same, except when assignedLocationCode becomes the receiving location code after a transfer shipment is shipped.
     * Get Shipment
     */
    async getShipmentUsingGET(requestParameters: ShipmentApiGetShipmentUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.getShipmentUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A paged list of shipments is returned according to any specified filter criteria and sort options
     * Get Shipments
     */


    async getShipmentsUsingGETRaw(requestParameters: ShipmentApiGetShipmentsUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PagedModelOfEntityModelOfShipment>> {
        const queryParameters: any = {};

        if (requestParameters.bypassSearchIndex !== undefined) {
            queryParameters['bypassSearchIndex'] = requestParameters.bypassSearchIndex;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.isLate !== undefined) {
            queryParameters['isLate'] = requestParameters.isLate;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.quickSearch !== undefined) {
            queryParameters['quickSearch'] = requestParameters.quickSearch;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.workflowTaskName !== undefined) {
            queryParameters['workflowTaskName'] = requestParameters.workflowTaskName;
        }

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PagedModelOfEntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * A paged list of shipments is returned according to any specified filter criteria and sort options
     * Get Shipments
     */
    async getShipmentsUsingGET(requestParameters: ShipmentApiGetShipmentsUsingGETRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PagedModelOfEntityModelOfShipment> {
        const response = await this.getShipmentsUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Tasks
     * Get Workflow Tasks
     */


    async getTasksUsingGETRaw(requestParameters: ShipmentApiGetTasksUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelOfTask>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling getTasksUsingGET.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionModelOfTaskFromJSON(jsonValue));
    }

    /**
     * Get Workflow Tasks
     * Get Workflow Tasks
     */
    async getTasksUsingGET(requestParameters: ShipmentApiGetTasksUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelOfTask> {
        const response = await this.getTasksUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Shipment
     * Create Shipment
     */


    async newShipmentUsingPOSTRaw(requestParameters: ShipmentApiNewShipmentUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShipmentToJSON(requestParameters.shipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Create Shipment
     * Create Shipment
     */
    async newShipmentUsingPOST(requestParameters: ShipmentApiNewShipmentUsingPOSTRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.newShipmentUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk Create Shipments
     * Bulk Create Shipments
     */


    async newShipmentsUsingPOSTRaw(requestParameters: ShipmentApiNewShipmentsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionModelOfEntityModelOfShipment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.shipment.map(ShipmentToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionModelOfEntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Bulk Create Shipments
     * Bulk Create Shipments
     */
    async newShipmentsUsingPOST(requestParameters: ShipmentApiNewShipmentsUsingPOSTRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionModelOfEntityModelOfShipment> {
        const response = await this.newShipmentsUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
     * Pickup Items
     */


    async pickupItemsUsingPOSTRaw(requestParameters: ShipmentApiPickupItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling pickupItemsUsingPOST.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/pickedUpItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupItemsRequestToJSON(requestParameters.pickupItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Individual items within a shipment can be marked as picked up in BOPIS (Buy Online Pickup in Store) shipments. This is particularly useful in cases such as partial pickup, in which the pickup location requested a transfer for some items that they did not have in stock but they allow the customer to pick up the items they have ready. In this event, the pickup shipment cannot go straight to the Fulfilled (“Complete”) step because it is still waiting on other items to be received. That partial quantity of items that are picked up early can be called out through this API.
     * Pickup Items
     */
    async pickupItemsUsingPOST(requestParameters: ShipmentApiPickupItemsUsingPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.pickupItemsUsingPOSTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
     * Reassign Items
     */


    async reassignItemsUsingPUTRaw(requestParameters: ShipmentApiReassignItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling reassignItemsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/reassignedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReassignItemsRequestToJSON(requestParameters.reassignItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Reassign particular items from a shipment while leaving the rest of the items at the original location. This is often referred to as “splitting the shipment.
     * Reassign Items
     */
    async reassignItemsUsingPUT(requestParameters: ShipmentApiReassignItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.reassignItemsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
     * Reassign Shipment
     */


    async reassignShipmentUsingPUTRaw(requestParameters: ShipmentApiReassignShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling reassignShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/reassigned`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReassignShipmentToJSON(requestParameters.reassignShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Reassign an entire shipment to a new fulfillment location, including all packages and items within it. Note that the blockAssignment field is not always necessary to provide in the request, as OMS defaults to “false” if it is not provided in the request. However, it must be provided in order to enable the assignment blocking when desired, such as if the reassignment was due to lack of inventory and similar shipments should not be assigned to this location until it has inventory back in stock.
     * Reassign Shipment
     */
    async reassignShipmentUsingPUT(requestParameters: ShipmentApiReassignShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.reassignShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
     * Receive Transfer
     */


    async receiveTransferUsingPUTRaw(requestParameters: ShipmentApiReceiveTransferUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling receiveTransferUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/received`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * After a transfer shipment has been created and fulfilled by the second location, the original pickup location that requested those transfer items must indicate that they have received everything before they can progress in the BOPIS fulfillment flow. Once the location validates that they have received their transfers with this call, the shipment will leave the Wait For Transfer state and continue to Customer Pickup.
     * Receive Transfer
     */
    async receiveTransferUsingPUT(requestParameters: ShipmentApiReceiveTransferUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.receiveTransferUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refresh Shipment
     * Refresh Shipment
     */


    async refreshShipmentUsingPUTRaw(requestParameters: ShipmentApiRefreshShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling refreshShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        if (requestParameters.shouldLog !== undefined) {
            queryParameters['shouldLog'] = requestParameters.shouldLog;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/refresh`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Refresh Shipment
     * Refresh Shipment
     */
    async refreshShipmentUsingPUT(requestParameters: ShipmentApiRefreshShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.refreshShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
     * Reject Items
     */


    async rejectItemsUsingPUTRaw(requestParameters: ShipmentApiRejectItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling rejectItemsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rejectedItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RejectItemsRequestToJSON(requestParameters.rejectItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Reject items in the shipment that are not available for fulfillment at this location. This will assign a new transfer shipment to an eligible location based on order routing rules.
     * Reject Items
     */
    async rejectItemsUsingPUT(requestParameters: ShipmentApiRejectItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.rejectItemsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
     * Reject Shipment
     */


    async rejectShipmentUsingPUTRaw(requestParameters: ShipmentApiRejectShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling rejectShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rejected`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RejectShipmentToJSON(requestParameters.rejectShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Reject an entire shipment whose items are not available for fulfillment at this location. This will reassign the shipment to an eligible location based on order routing rules.
     * Reject Shipment
     */
    async rejectShipmentUsingPUT(requestParameters: ShipmentApiRejectShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.rejectShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Render order summary by shipment number in HTML format for printing
     * Render Order Summary by Shipment Number
     */


    async renderOrderSummaryUsingGET1Raw(requestParameters: ShipmentApiRenderOrderSummaryUsingGET1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfstring>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling renderOrderSummaryUsingGET1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/order-summary/html`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfstringFromJSON(jsonValue));
    }

    /**
     * Render order summary by shipment number in HTML format for printing
     * Render Order Summary by Shipment Number
     */
    async renderOrderSummaryUsingGET1(requestParameters: ShipmentApiRenderOrderSummaryUsingGET1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfstring> {
        const response = await this.renderOrderSummaryUsingGET1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Render shipment packing slip in HTML format for printing
     * Render Shipment Packing Slip
     */


    async renderPackingSlipUsingGETRaw(requestParameters: ShipmentApiRenderPackingSlipUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfstring>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling renderPackingSlipUsingGET.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/rendition/html`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfstringFromJSON(jsonValue));
    }

    /**
     * Render shipment packing slip in HTML format for printing
     * Render Shipment Packing Slip
     */
    async renderPackingSlipUsingGET(requestParameters: ShipmentApiRenderPackingSlipUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfstring> {
        const response = await this.renderPackingSlipUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Shipment
     * Update Shipment
     */


    async replaceShipmentUsingPUTRaw(requestParameters: ShipmentApiReplaceShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling replaceShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateFields !== undefined) {
            queryParameters['updateFields'] = requestParameters.updateFields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShipmentToJSON(requestParameters.shipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Update Shipment
     * Update Shipment
     */
    async replaceShipmentUsingPUT(requestParameters: ShipmentApiReplaceShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.replaceShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resend Item Email
     * Resend Item Email
     */


    async resendItemEmailUsingPUTRaw(requestParameters: ShipmentApiResendItemEmailUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling resendItemEmailUsingPUT.');
        }

        if (requestParameters.lineId === null || requestParameters.lineId === undefined) {
            throw new runtime.RequiredError('lineId','Required parameter requestParameters.lineId was null or undefined when calling resendItemEmailUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/items/{lineId}/email/resend`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"lineId"}}`, encodeURIComponent(String(requestParameters.lineId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resend Item Email
     * Resend Item Email
     */
    async resendItemEmailUsingPUT(requestParameters: ShipmentApiResendItemEmailUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resendItemEmailUsingPUTRaw(requestParameters, initOverrides);
    }

    /**
     * Resend Shipment Email
     * Resend Shipment Email
     */


    async resendShipmentEmailUsingPUTRaw(requestParameters: ShipmentApiResendShipmentEmailUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling resendShipmentEmailUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/email/resend`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resend Shipment Email
     * Resend Shipment Email
     */
    async resendShipmentEmailUsingPUT(requestParameters: ShipmentApiResendShipmentEmailUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resendShipmentEmailUsingPUTRaw(requestParameters, initOverrides);
    }

    /**
     * Retry Fulfilling Shipment
     * Retry Fulfilling Shipment
     */


    async retryFulfillingShipmentUsingPUTRaw(requestParameters: ShipmentApiRetryFulfillingShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling retryFulfillingShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/retried`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Retry Fulfilling Shipment
     * Retry Fulfilling Shipment
     */
    async retryFulfillingShipmentUsingPUT(requestParameters: ShipmentApiRetryFulfillingShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.retryFulfillingShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revert Workflow Task
     * Revert Workflow Task
     */


    async revertUsingPUTRaw(requestParameters: ShipmentApiRevertUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling revertUsingPUT.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling revertUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/reverted`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Revert Workflow Task
     * Revert Workflow Task
     */
    async revertUsingPUT(requestParameters: ShipmentApiRevertUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.revertUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and Receive Transfer
     * Find and Receive Transfer
     */


    async searchAndReceiveTransferUsingPUTRaw(requestParameters: ShipmentApiSearchAndReceiveTransferUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchAndReceiveTransferUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/received/{search}`.replace(`{${"search"}}`, encodeURIComponent(String(requestParameters.search))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Find and Receive Transfer
     * Find and Receive Transfer
     */
    async searchAndReceiveTransferUsingPUT(requestParameters: ShipmentApiSearchAndReceiveTransferUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.searchAndReceiveTransferUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Skip Workflow Task
     * Skip Workflow Task
     */


    async skipTaskUsingPUTRaw(requestParameters: ShipmentApiSkipTaskUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling skipTaskUsingPUT.');
        }

        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling skipTaskUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/tasks/{taskName}/skipped`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))).replace(`{${"taskName"}}`, encodeURIComponent(String(requestParameters.taskName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Skip Workflow Task
     * Skip Workflow Task
     */
    async skipTaskUsingPUT(requestParameters: ShipmentApiSkipTaskUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.skipTaskUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
     * Transfer Items
     */


    async transferItemsUsingPUTRaw(requestParameters: ShipmentApiTransferItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling transferItemsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/transferredItems`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TransferItemsRequestToJSON(requestParameters.transferItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the unavailable items to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order. It is possible for only some items in the shipment to be needed as a transfer, as opposed to the entire shipment, so this API facilitates creating a transfer for those specific items and quantities.
     * Transfer Items
     */
    async transferItemsUsingPUT(requestParameters: ShipmentApiTransferItemsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.transferItemsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
     * Transfer Shipment
     */


    async transferShipmentUsingPUTRaw(requestParameters: ShipmentApiTransferShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling transferShipmentUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/transferred`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TransferShipmentToJSON(requestParameters.transferShipment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * If a pickup location for a BOPIS (Buy Online Pickup in Store) shipment does not have all items available in stock, then they can request a transfer from another location. Submitting this transfer request will send the information about the shipment to a second location, who will then ship the items to the fulfiller so that the customer can pick them up at the original store location they selected when submitting their order.
     * Transfer Shipment
     */
    async transferShipmentUsingPUT(requestParameters: ShipmentApiTransferShipmentUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.transferShipmentUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Fulfillment Fields
     * Update Fulfillment Fields
     */


    async updateFulfillmentFieldsUsingPUTRaw(requestParameters: ShipmentApiUpdateFulfillmentFieldsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling updateFulfillmentFieldsUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/fulfillmentFields`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.item.map(ItemToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Update Fulfillment Fields
     * Update Fulfillment Fields
     */
    async updateFulfillmentFieldsUsingPUT(requestParameters: ShipmentApiUpdateFulfillmentFieldsUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.updateFulfillmentFieldsUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Gift Card Info
     * Update Gift Card Info
     */


    async updateGiftCardInfoUsingPUTRaw(requestParameters: ShipmentApiUpdateGiftCardInfoUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityModelOfShipment>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling updateGiftCardInfoUsingPUT.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/giftCardInfo`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GiftCardInfoRequestToJSON(requestParameters.giftCardInfoRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityModelOfShipmentFromJSON(jsonValue));
    }

    /**
     * Update Gift Card Info
     * Update Gift Card Info
     */
    async updateGiftCardInfoUsingPUT(requestParameters: ShipmentApiUpdateGiftCardInfoUsingPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityModelOfShipment> {
        const response = await this.updateGiftCardInfoUsingPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Definition Image
     * Get Workflow Definition Image
     */


    async workflowDefinitionImageUsingGETRaw(requestParameters: ShipmentApiWorkflowDefinitionImageUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling workflowDefinitionImageUsingGET.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/workflow-definition-image`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Workflow Definition Image
     * Get Workflow Definition Image
     */
    async workflowDefinitionImageUsingGET(requestParameters: ShipmentApiWorkflowDefinitionImageUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.workflowDefinitionImageUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow Instance Image
     * Get Workflow Instance Image
     */


    async workflowInstanceImageUsingGETRaw(requestParameters: ShipmentApiWorkflowInstanceImageUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.shipmentNumber === null || requestParameters.shipmentNumber === undefined) {
            throw new runtime.RequiredError('shipmentNumber','Required parameter requestParameters.shipmentNumber was null or undefined when calling workflowInstanceImageUsingGET.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        if (this.configuration && (this.configuration.accessToken || this.configuration.clientId && this.configuration.sharedSecret)) {
            const token = await this.configuration.accessToken;
            const tokenString = await token();
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        
        if (this.configuration && this.configuration.jwt) {
            const token = this.configuration.jwt;
            const tokenString = await token();

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/commerce/shipments/{shipmentNumber}/workflow-instance-image`.replace(`{${"shipmentNumber"}}`, encodeURIComponent(String(requestParameters.shipmentNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Workflow Instance Image
     * Get Workflow Instance Image
     */
    async workflowInstanceImageUsingGET(requestParameters: ShipmentApiWorkflowInstanceImageUsingGETRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.workflowInstanceImageUsingGETRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

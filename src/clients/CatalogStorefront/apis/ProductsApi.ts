/* tslint:disable */
/* eslint-disable */
/**
 * Kibo Catalog Runtime Services
 * OpenAPI Spec for Kibo Catalog Runtime Services
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../../client-runtime';
import { basePathTemplate } from '../api-path';
import type {
  ConfiguredProduct,
  DiscountSelections,
  DiscountValidationSummary,
  LocationInventoryCollection,
  LocationInventoryQuery,
  Product,
  ProductCollection,
  ProductCostCollection,
  ProductCostQuery,
  ProductForIndexing,
  ProductOptionSelections,
  ProductSubstituteCollection,
  ProductValidationSummary,
} from '../models';
import {
    ConfiguredProductFromJSON,
    ConfiguredProductToJSON,
    DiscountSelectionsFromJSON,
    DiscountSelectionsToJSON,
    DiscountValidationSummaryFromJSON,
    DiscountValidationSummaryToJSON,
    LocationInventoryCollectionFromJSON,
    LocationInventoryCollectionToJSON,
    LocationInventoryQueryFromJSON,
    LocationInventoryQueryToJSON,
    ProductFromJSON,
    ProductToJSON,
    ProductCollectionFromJSON,
    ProductCollectionToJSON,
    ProductCostCollectionFromJSON,
    ProductCostCollectionToJSON,
    ProductCostQueryFromJSON,
    ProductCostQueryToJSON,
    ProductForIndexingFromJSON,
    ProductForIndexingToJSON,
    ProductOptionSelectionsFromJSON,
    ProductOptionSelectionsToJSON,
    ProductSubstituteCollectionFromJSON,
    ProductSubstituteCollectionToJSON,
    ProductValidationSummaryFromJSON,
    ProductValidationSummaryToJSON,
} from '../models';

export interface ProductsApiStorefrontConfigureProductRequest {
    productCode: string;
    includeOptionDetails?: boolean;
    skipInventoryCheck?: boolean;
    quantity?: number;
    purchaseLocation?: string;
    variationProductCodeFilter?: string;
    useSubscriptionPricing?: boolean;
    subscriptionFrequency?: string;
    productOptionSelections?: ProductOptionSelections;
}

export interface ProductsApiStorefrontGetProductRequest {
    productCode: string;
    variationProductCode?: string;
    responseGroups?: string;
    allowInactive?: boolean;
    skipInventoryCheck?: boolean;
    supressOutOfStock404?: boolean;
    quantity?: number;
    acceptVariantProductCode?: boolean;
    purchaseLocation?: string;
    variationProductCodeFilter?: string;
    sliceValue?: string;
    includeAllImages?: boolean;
    useSubscriptionPricing?: boolean;
}

export interface ProductsApiStorefrontGetProductCostsRequest {
    productCostQuery?: ProductCostQuery;
}

export interface ProductsApiStorefrontGetProductForIndexingRequest {
    productCode: string;
    responseGroups?: string;
    productVersion?: number;
    lastModifiedDate?: Date;
}

export interface ProductsApiStorefrontGetProductInventoriesRequest {
    locationInventoryQuery?: LocationInventoryQuery;
}

export interface ProductsApiStorefrontGetProductInventoryRequest {
    productCode: string;
    locationCodes?: string;
}

export interface ProductsApiStorefrontGetProductsRequest {
    filter?: string;
    startIndex?: number;
    pageSize?: number;
    sortBy?: string;
    responseGroups?: string;
    responseOptions?: string;
    cursorMark?: string;
    defaultSort?: string;
    mid?: string;
    includeAllImages?: boolean;
    useSubscriptionPricing?: boolean;
    includeProductDetailsOnlyProperty?: boolean;
}

export interface ProductsApiStorefrontProductSubstitutionsRequest {
    productCode: string;
}

export interface ProductsApiStorefrontValidateDiscountsRequest {
    productCode: string;
    variationProductCode?: string;
    customerAccountId?: number;
    allowInactive?: boolean;
    skipInventoryCheck?: boolean;
    discountSelections?: DiscountSelections;
}

export interface ProductsApiStorefrontValidateProductRequest {
    productCode: string;
    skipInventoryCheck?: boolean;
    quantity?: number;
    skipDefaults?: boolean;
    purchaseLocation?: string;
    useSubscriptionPricing?: boolean;
    recalculateDynamicCategories?: boolean;
    acceptVariantProductCode?: boolean;
    productOptionSelections?: ProductOptionSelections;
}

/**
 * 
 */
export class ProductsApi extends runtime.BaseAPI {
    constructor(configuration?) {
        super(configuration)
        this.basePathTemplate = basePathTemplate
    }
    /**
     * Creates a new product selection. A create occurs each time a shopper selects a product option as they configure a product. Once all the required product options are configured, the product can be added to a cart.
     * Configures a variant product
     */


    async storefrontConfigureProductRaw(requestParameters: ProductsApiStorefrontConfigureProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConfiguredProduct>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontConfigureProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeOptionDetails !== undefined) {
            queryParameters['includeOptionDetails'] = requestParameters.includeOptionDetails;
        }

        if (requestParameters.skipInventoryCheck !== undefined) {
            queryParameters['skipInventoryCheck'] = requestParameters.skipInventoryCheck;
        }

        if (requestParameters.quantity !== undefined) {
            queryParameters['quantity'] = requestParameters.quantity;
        }

        if (requestParameters.purchaseLocation !== undefined) {
            queryParameters['purchaseLocation'] = requestParameters.purchaseLocation;
        }

        if (requestParameters.variationProductCodeFilter !== undefined) {
            queryParameters['variationProductCodeFilter'] = requestParameters.variationProductCodeFilter;
        }

        if (requestParameters.useSubscriptionPricing !== undefined) {
            queryParameters['useSubscriptionPricing'] = requestParameters.useSubscriptionPricing;
        }

        if (requestParameters.subscriptionFrequency !== undefined) {
            queryParameters['subscriptionFrequency'] = requestParameters.subscriptionFrequency;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}/configure`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductOptionSelectionsToJSON(requestParameters.productOptionSelections),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConfiguredProductFromJSON(jsonValue));
    }

    /**
     * Creates a new product selection. A create occurs each time a shopper selects a product option as they configure a product. Once all the required product options are configured, the product can be added to a cart.
     * Configures a variant product
     */
    async storefrontConfigureProduct(requestParameters: ProductsApiStorefrontConfigureProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConfiguredProduct> {
        const response = await this.storefrontConfigureProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves information about a single product given its product code.
     * Get a product
     */


    async storefrontGetProductRaw(requestParameters: ProductsApiStorefrontGetProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Product>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontGetProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.variationProductCode !== undefined) {
            queryParameters['variationProductCode'] = requestParameters.variationProductCode;
        }

        if (requestParameters.responseGroups !== undefined) {
            queryParameters['responseGroups'] = requestParameters.responseGroups;
        }

        if (requestParameters.allowInactive !== undefined) {
            queryParameters['allowInactive'] = requestParameters.allowInactive;
        }

        if (requestParameters.skipInventoryCheck !== undefined) {
            queryParameters['skipInventoryCheck'] = requestParameters.skipInventoryCheck;
        }

        if (requestParameters.supressOutOfStock404 !== undefined) {
            queryParameters['supressOutOfStock404'] = requestParameters.supressOutOfStock404;
        }

        if (requestParameters.quantity !== undefined) {
            queryParameters['quantity'] = requestParameters.quantity;
        }

        if (requestParameters.acceptVariantProductCode !== undefined) {
            queryParameters['acceptVariantProductCode'] = requestParameters.acceptVariantProductCode;
        }

        if (requestParameters.purchaseLocation !== undefined) {
            queryParameters['purchaseLocation'] = requestParameters.purchaseLocation;
        }

        if (requestParameters.variationProductCodeFilter !== undefined) {
            queryParameters['variationProductCodeFilter'] = requestParameters.variationProductCodeFilter;
        }

        if (requestParameters.sliceValue !== undefined) {
            queryParameters['sliceValue'] = requestParameters.sliceValue;
        }

        if (requestParameters.includeAllImages !== undefined) {
            queryParameters['includeAllImages'] = requestParameters.includeAllImages;
        }

        if (requestParameters.useSubscriptionPricing !== undefined) {
            queryParameters['useSubscriptionPricing'] = requestParameters.useSubscriptionPricing;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductFromJSON(jsonValue));
    }

    /**
     * Retrieves information about a single product given its product code.
     * Get a product
     */
    async storefrontGetProduct(requestParameters: ProductsApiStorefrontGetProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Product> {
        const response = await this.storefrontGetProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get costs for products
     * Get costs for products
     */


    async storefrontGetProductCostsRaw(requestParameters: ProductsApiStorefrontGetProductCostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductCostCollection>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/costs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductCostQueryToJSON(requestParameters.productCostQuery),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductCostCollectionFromJSON(jsonValue));
    }

    /**
     * Get costs for products
     * Get costs for products
     */
    async storefrontGetProductCosts(requestParameters: ProductsApiStorefrontGetProductCostsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductCostCollection> {
        const response = await this.storefrontGetProductCostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves information about a single product given its product code for Mozu to index in the search engine
     * Get a product for indexing
     */


    async storefrontGetProductForIndexingRaw(requestParameters: ProductsApiStorefrontGetProductForIndexingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductForIndexing>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontGetProductForIndexing.');
        }

        const queryParameters: any = {};

        if (requestParameters.responseGroups !== undefined) {
            queryParameters['responseGroups'] = requestParameters.responseGroups;
        }

        if (requestParameters.productVersion !== undefined) {
            queryParameters['productVersion'] = requestParameters.productVersion;
        }

        if (requestParameters.lastModifiedDate !== undefined) {
            queryParameters['lastModifiedDate'] = (requestParameters.lastModifiedDate as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/indexing/{productCode}`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductForIndexingFromJSON(jsonValue));
    }

    /**
     * Retrieves information about a single product given its product code for Mozu to index in the search engine
     * Get a product for indexing
     */
    async storefrontGetProductForIndexing(requestParameters: ProductsApiStorefrontGetProductForIndexingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductForIndexing> {
        const response = await this.storefrontGetProductForIndexingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get location inventories for products
     * Get location inventories for products
     */


    async storefrontGetProductInventoriesRaw(requestParameters: ProductsApiStorefrontGetProductInventoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationInventoryCollection>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/locationinventory`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationInventoryQueryToJSON(requestParameters.locationInventoryQuery),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationInventoryCollectionFromJSON(jsonValue));
    }

    /**
     * Get location inventories for products
     * Get location inventories for products
     */
    async storefrontGetProductInventories(requestParameters: ProductsApiStorefrontGetProductInventoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationInventoryCollection> {
        const response = await this.storefrontGetProductInventoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get product inventory
     * Get product inventory
     */


    async storefrontGetProductInventoryRaw(requestParameters: ProductsApiStorefrontGetProductInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationInventoryCollection>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontGetProductInventory.');
        }

        const queryParameters: any = {};

        if (requestParameters.locationCodes !== undefined) {
            queryParameters['locationCodes'] = requestParameters.locationCodes;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}/locationinventory`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationInventoryCollectionFromJSON(jsonValue));
    }

    /**
     * Get product inventory
     * Get product inventory
     */
    async storefrontGetProductInventory(requestParameters: ProductsApiStorefrontGetProductInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationInventoryCollection> {
        const response = await this.storefrontGetProductInventoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of products that appear on the storefront according to any specified filter criteria and sort options.
     * Get a list of products
     */


    async storefrontGetProductsRaw(requestParameters: ProductsApiStorefrontGetProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductCollection>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['startIndex'] = requestParameters.startIndex;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.responseGroups !== undefined) {
            queryParameters['responseGroups'] = requestParameters.responseGroups;
        }

        if (requestParameters.responseOptions !== undefined) {
            queryParameters['responseOptions'] = requestParameters.responseOptions;
        }

        if (requestParameters.cursorMark !== undefined) {
            queryParameters['cursorMark'] = requestParameters.cursorMark;
        }

        if (requestParameters.defaultSort !== undefined) {
            queryParameters['defaultSort'] = requestParameters.defaultSort;
        }

        if (requestParameters.mid !== undefined) {
            queryParameters['mid'] = requestParameters.mid;
        }

        if (requestParameters.includeAllImages !== undefined) {
            queryParameters['includeAllImages'] = requestParameters.includeAllImages;
        }

        if (requestParameters.useSubscriptionPricing !== undefined) {
            queryParameters['useSubscriptionPricing'] = requestParameters.useSubscriptionPricing;
        }

        if (requestParameters.includeProductDetailsOnlyProperty !== undefined) {
            queryParameters['includeProductDetailsOnlyProperty'] = requestParameters.includeProductDetailsOnlyProperty;
        }

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductCollectionFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of products that appear on the storefront according to any specified filter criteria and sort options.
     * Get a list of products
     */
    async storefrontGetProducts(requestParameters: ProductsApiStorefrontGetProductsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductCollection> {
        const response = await this.storefrontGetProductsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of up to 10 products that can be substituted for the provided product code.
     * Get product substitutions
     */


    async storefrontProductSubstitutionsRaw(requestParameters: ProductsApiStorefrontProductSubstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductSubstituteCollection>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontProductSubstitutions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}/substitutions`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductSubstituteCollectionFromJSON(jsonValue));
    }

    /**
     * Returns a list of up to 10 products that can be substituted for the provided product code.
     * Get product substitutions
     */
    async storefrontProductSubstitutions(requestParameters: ProductsApiStorefrontProductSubstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductSubstituteCollection> {
        const response = await this.storefrontProductSubstitutionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validate if a collection of discounts is valid for a product.  This includes discounts that would normally be considered order level discounts.
     * Validates discounts for a product
     */


    async storefrontValidateDiscountsRaw(requestParameters: ProductsApiStorefrontValidateDiscountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiscountValidationSummary>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontValidateDiscounts.');
        }

        const queryParameters: any = {};

        if (requestParameters.variationProductCode !== undefined) {
            queryParameters['variationProductCode'] = requestParameters.variationProductCode;
        }

        if (requestParameters.customerAccountId !== undefined) {
            queryParameters['customerAccountId'] = requestParameters.customerAccountId;
        }

        if (requestParameters.allowInactive !== undefined) {
            queryParameters['allowInactive'] = requestParameters.allowInactive;
        }

        if (requestParameters.skipInventoryCheck !== undefined) {
            queryParameters['skipInventoryCheck'] = requestParameters.skipInventoryCheck;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}/validateDiscounts`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DiscountSelectionsToJSON(requestParameters.discountSelections),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DiscountValidationSummaryFromJSON(jsonValue));
    }

    /**
     * Validate if a collection of discounts is valid for a product.  This includes discounts that would normally be considered order level discounts.
     * Validates discounts for a product
     */
    async storefrontValidateDiscounts(requestParameters: ProductsApiStorefrontValidateDiscountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiscountValidationSummary> {
        const response = await this.storefrontValidateDiscountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validate the final state of shopper-selected options.
     * Validates a variant product
     */


    async storefrontValidateProductRaw(requestParameters: ProductsApiStorefrontValidateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductValidationSummary>> {
        if (requestParameters.productCode === null || requestParameters.productCode === undefined) {
            throw new runtime.RequiredError('productCode','Required parameter requestParameters.productCode was null or undefined when calling storefrontValidateProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.skipInventoryCheck !== undefined) {
            queryParameters['skipInventoryCheck'] = requestParameters.skipInventoryCheck;
        }

        if (requestParameters.quantity !== undefined) {
            queryParameters['quantity'] = requestParameters.quantity;
        }

        if (requestParameters.skipDefaults !== undefined) {
            queryParameters['skipDefaults'] = requestParameters.skipDefaults;
        }

        if (requestParameters.purchaseLocation !== undefined) {
            queryParameters['purchaseLocation'] = requestParameters.purchaseLocation;
        }

        if (requestParameters.useSubscriptionPricing !== undefined) {
            queryParameters['useSubscriptionPricing'] = requestParameters.useSubscriptionPricing;
        }

        if (requestParameters.recalculateDynamicCategories !== undefined) {
            queryParameters['recalculateDynamicCategories'] = requestParameters.recalculateDynamicCategories;
        }

        if (requestParameters.acceptVariantProductCode !== undefined) {
            queryParameters['acceptVariantProductCode'] = requestParameters.acceptVariantProductCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';





        await this.addAuthorizationHeaders(headerParameters)
        
        const response = await this.request({
            path: `/commerce/catalog/storefront/products/{productCode}/validate`.replace(`{${"productCode"}}`, encodeURIComponent(String(requestParameters.productCode))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductOptionSelectionsToJSON(requestParameters.productOptionSelections),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductValidationSummaryFromJSON(jsonValue));
    }

    /**
     * Validate the final state of shopper-selected options.
     * Validates a variant product
     */
    async storefrontValidateProduct(requestParameters: ProductsApiStorefrontValidateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductValidationSummary> {
        const response = await this.storefrontValidateProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
